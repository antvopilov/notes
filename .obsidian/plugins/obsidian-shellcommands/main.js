/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');
var child_process = require('child_process');
var electron = require('electron');
var os = require('os');
var path = require('path');
var fs = require('fs');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var path__namespace = /*#__PURE__*/_interopNamespace(path);
var fs__namespace = /*#__PURE__*/_interopNamespace(fs);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function getVaultAbsolutePath(app) {
    // Original code was copied 2021-08-22 from https://github.com/phibr0/obsidian-open-with/blob/84f0e25ba8e8355ff83b22f4050adde4cc6763ea/main.ts#L66-L67
    // But the code has been rewritten 2021-08-27 as per https://github.com/obsidianmd/obsidian-releases/pull/433#issuecomment-906087095
    let adapter = app.vault.adapter;
    if (adapter instanceof obsidian.FileSystemAdapter) {
        return adapter.getBasePath();
    }
    return null;
}
/**
 * For some reason there is no Platform.isWindows .
 */
function isWindows() {
    return process.platform === "win32";
}
function getView(app) {
    let view = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
    if (!view) {
        console.log("getView(): Could not get a view. Will return null.");
        return null;
    }
    return view;
}
function getEditor(app) {
    let view = getView(app);
    if (null === view) {
        // Could not get a view.
        return null;
    }
    // Ensure that view.editor exists! It exists at least if this is a MarkDownView.
    if ("editor" in view) {
        // Good, it exists.
        // @ts-ignore We already know that view.editor exists.
        return view.editor;
    }
    // Did not find an editor.
    console.log("getEditor(): 'view' does not have a property named 'editor'. Will return null.");
    return null;
}
function cloneObject(object) {
    return Object.assign({}, object);
}
/**
 * Same as normalizePath(), but fixes these glitches:
 * - Leading forward slashes / backward slashes should not be removed.
 * - \ should not be converted to / if platform is Windows. In other words, / should be converted to \ if platform is Windows.
 *
 * TODO: I've opened a discussion about this on Obsidian's forums. If anything new comes up in the discussion, make changes accordingly. https://forum.obsidian.md/t/normalizepath-removes-a-leading/24713
 */
function normalizePath2(path) {
    // 1. Preparations
    path = path.trim();
    let leading_slashes_regexp = /^[/\\]*/g; // Get as many / or \ slashes as there are in the very beginning of path. Can also be "" (an empty string).
    let leading_slashes = leading_slashes_regexp.exec(path)[0];
    // 2. Run the original normalizePath()
    path = obsidian.normalizePath(path);
    // 3. Fixes
    // Check that correct slashes are used.
    if (isWindows()) {
        // The platform is Windows.
        // Convert / to \
        path = path.replace(/\//g, "\\"); // Need to use a regexp instead of a normal "/" -> "\\" replace because the normal replace would only replace first occurrence of /.
        leading_slashes = leading_slashes.replace(/\//g, "\\"); // Same here.
    }
    // Now ensure that path still contains leading slashes (if there were any before calling normalizePath()).
    // Check that the path should have a similar set of leading slashes at the beginning. It can be at least "/" (on linux/Mac), or "\\" (on Windows when it's a network path), in theory even "///" or "\\\\\" whatever.
    // normalizePath() seems to remove leading slashes (and they are needed to be re-added), but it's needed to check first, otherwise the path would have double leading slashes if normalizePath() gets fixed in the future.
    if (leading_slashes.length && path.slice(0, leading_slashes.length) !== leading_slashes) {
        // The path does not contain the required set of leading slashes, so add them.
        path = leading_slashes + path;
    }
    // 4. Done
    return path;
}
function joinObjectProperties(object, glue) {
    let result = "";
    for (let property_name in object) {
        if (result.length) {
            result += glue;
        }
        // @ts-ignore
        result += object[property_name];
    }
    return result;
}
/**
 * Removes all duplicates from an array.
 *
 * Idea is copied 2021-10-06 from https://stackoverflow.com/a/33121880/2754026
 */
function uniqueArray(array) {
    return [...new Set(array)];
}

let shell_command_variable_instructions = [];
function getShellCommandVariableInstructions() {
    sort_shell_command_variable_instructions(); // Make sure the variables are in correct order.
    return shell_command_variable_instructions;
}
function addShellCommandVariableInstructions(variable_name, instructions) {
    shell_command_variable_instructions.push({
        variable_name: variable_name,
        instructions: instructions,
    });
}
/**
 * Sorts shell_command_variable_instructions alphabetically based on variable_name.
 */
function sort_shell_command_variable_instructions() {
    shell_command_variable_instructions.sort((a, b) => {
        if (a.variable_name < b.variable_name) {
            return -1;
        }
        else if (a.variable_name > b.variable_name) {
            return 1;
        }
        return 0;
    });
}

class ShellCommandVariable {
    constructor(plugin) {
        this.parameter_separator = ":";
        this.error_messages = [];
        /**
         * A definition for what parameters this variables takes.
         * @protected
         */
        this.parameters = {};
        /**
         * This contains actual values for parameters.
         * @protected
         */
        this.arguments = {};
        this.plugin = plugin;
        this.app = plugin.app;
    }
    getPattern() {
        const error_prefix = this.name + ".getPattern(): ";
        let pattern = '\{\{' + this.name;
        for (let parameter_name in this.parameters) {
            const parameter = this.parameters[parameter_name];
            let parameter_type_pattern = this.parameter_separator; // Here this.parameter_separator (= : ) is included in the parameter value just so that it's not needed to do nested parenthesis to accomplish possible optionality: (:())?. parseShellCommandVariables() will remove the leading : .
            // Check should we use parameter.options or parameter.type.
            if (undefined === parameter.options &&
                undefined === parameter.type) {
                // Neither is defined :(
                throw Error(error_prefix + "Parameter '" + parameter_name + "' should define either 'type' or 'options', neither is defined!");
            }
            else if (undefined !== parameter.options &&
                undefined !== parameter.type) {
                // Both are defined :(
                throw Error(error_prefix + "Parameter '" + parameter_name + "' should define either 'type' or 'options', not both!");
            }
            else if (undefined !== parameter.options) {
                // Use parameter.options
                parameter_type_pattern += parameter.options.join("|" + this.parameter_separator); // E.g. "absolute|:relative" for {{file_path:mode}} variable's 'mode' parameter.
            }
            else {
                // Use parameter.type
                switch (parameter.type) {
                    case "string":
                        parameter_type_pattern += ".*?";
                        break;
                    case "integer":
                        parameter_type_pattern += "\\d+";
                        break;
                    default:
                        throw Error(error_prefix + "Parameter '" + parameter_name + "' has an unrecognised type: " + parameter.type);
                }
            }
            // Add the subpattern to 'pattern'.
            pattern += "(" + parameter_type_pattern + ")";
            if (!parameter.required) {
                // Make the parameter optional.
                pattern += "?";
            }
        }
        pattern += '\}\}';
        return pattern;
    }
    getParameterNames() {
        return Object.getOwnPropertyNames(this.parameters);
    }
    /**
     * @param parameter_name
     * @param argument At this point 'argument' is always a string, but this method may convert it to another data type, depending on the parameter's data type.
     */
    setArgument(parameter_name, argument) {
        var _a;
        const parameter_type = (_a = this.parameters[parameter_name].type) !== null && _a !== void 0 ? _a : "string"; // If the variable uses "options" instead of "type", then the type is always "string".
        switch (parameter_type) {
            case "string":
                this.arguments[parameter_name] = argument;
                break;
            case "integer":
                this.arguments[parameter_name] = parseInt(argument);
                break;
        }
    }
    /**
     * Note that error messages can only exist after getValue() is called!
     */
    getErrorMessages() {
        return this.error_messages;
    }
    newErrorMessage(message) {
        let prefix = "{{" + this.name + "}}: ";
        this.error_messages.push(prefix + message);
    }
}

class ShellCommandVariable_FolderName extends ShellCommandVariable {
    constructor() {
        super(...arguments);
        this.name = "folder_name";
    }
    getValue() {
        let file = this.app.workspace.getActiveFile();
        if (!file) {
            this.newErrorMessage("No file is active at the moment. Open a file or click a pane that has a file open.");
            return null; // null indicates that getting a value has failed and the command should not be executed.
        }
        if (!file.parent) {
            this.newErrorMessage("The current file does not have a parent for some strange reason.");
            return null; // null indicates that getting a value has failed and the command should not be executed.
        }
        return file.parent.name;
    }
}
addShellCommandVariableInstructions("{{folder_name}}", "Gives the current file's parent folder name. No ancestor folders are included.");

class ShellCommandVariable_Selection extends ShellCommandVariable {
    constructor() {
        super(...arguments);
        this.name = "selection";
    }
    getValue() {
        // Check that we are able to get a view
        let view = getView(this.app);
        if (null === view) {
            // Nope.
            this.newErrorMessage("Could not get a view instance! Please raise an issue in GitHub.");
            return null;
        }
        // Check that we are able to get an editor
        let editor = getEditor(this.app);
        if (null === editor) {
            // Nope.
            this.newErrorMessage("Could not get an editor instance! Please raise an issue in GitHub.");
            return null;
        }
        // Check the view mode
        let view_mode = view.getMode(); // "preview" or "source" (can also be "live" but I don't know when that happens)
        switch (view_mode) {
            case "preview":
                // The leaf is in preview mode, which makes things difficult.
                // We could still return view.editor, but it does not work at least for getting selected text, maybe for other things, but currently this function is only used for getting selected text.
                // At this moment, just return null to indicate that we were not able to offer an editor instance which could work reliably on text selections.
                // FIXME: Make it possible to use this feature also in preview mode.
                console.log("ShellCommandVariable_Selection: 'view' is in preview mode, and the poor guy who wrote this code, does not know how to return an editor instance that could be used for getting text selection.");
                this.newErrorMessage("You need to turn editing mode on, as I'm not able to get selected text when in preview mode. Blame the one who developed this plugin! This should be fixed in the future.");
                return null;
            case "source":
                // Good, the editor is in "source" mode, so it's possible to get a selection.
                if (editor.somethingSelected()) {
                    return editor.getSelection();
                }
                return "";
        }
    }
}
addShellCommandVariableInstructions("{{selection}}", "Gives the currently selected text. Atm only works in editing mode, not in preview mode!");

class ShellCommandVariable_FilePath extends ShellCommandVariable {
    constructor() {
        super(...arguments);
        this.name = "file_path";
        this.parameters = {
            mode: {
                options: ["absolute", "relative"],
                required: true,
            },
        };
    }
    getValue() {
        let active_file = this.app.workspace.getActiveFile();
        if (active_file) {
            switch (this.arguments.mode.toLowerCase()) {
                case "absolute":
                    return normalizePath2(getVaultAbsolutePath(this.app) + "/" + active_file.path);
                case "relative":
                    return normalizePath2(active_file.path); // Normalize to get a correct slash depending on platform. On Windows it should be \ .
            }
        }
        else {
            this.newErrorMessage("No file is active at the moment. Open a file or click a pane that has a file open.");
            return null; // null indicates that getting a value has failed and the command should not be executed.
        }
    }
}
addShellCommandVariableInstructions("{{file_path:relative}} or {{file_path:absolute}}", "Gives path to the current file, either as absolute from the root of the file system, or as relative from the root of the Obsidian vault.");

class ShellCommandVariable_Clipboard extends ShellCommandVariable {
    constructor() {
        super(...arguments);
        this.name = "clipboard";
    }
    getValue() {
        return electron.clipboard.readText();
    }
}
addShellCommandVariableInstructions("{{clipboard}}", "Gives the content you last copied to your clipboard.");

class ShellCommandVariable_Date extends ShellCommandVariable {
    constructor() {
        super(...arguments);
        this.name = "date";
        this.parameters = {
            format: {
                type: "string",
                required: true,
            },
        };
    }
    getValue() {
        return obsidian.moment().format(this.arguments.format);
    }
}
addShellCommandVariableInstructions("{{date:format}}", "Gives a date/time stamp as per your liking. The \"format\" part can be customized and is mandatory. Formatting options: https://momentjs.com/docs/#/displaying/format/");

class ShellCommandVariable_VaultPath extends ShellCommandVariable {
    constructor() {
        super(...arguments);
        this.name = "vault_path";
    }
    getValue() {
        return getVaultAbsolutePath(this.app);
    }
}
addShellCommandVariableInstructions("{{vault_path}}", "Gives the Obsidian vault's absolute path from the root of the filesystem. This is the same that is used as a default working directory if you do not define one manually. If you define a working directory manually, this variable won't give you your manually defined directory, it always gives the vault's root directory.");

class ShellCommandVariable_FileName extends ShellCommandVariable {
    constructor() {
        super(...arguments);
        this.name = "file_name";
    }
    getValue() {
        let file = this.app.workspace.getActiveFile();
        if (!file) {
            this.newErrorMessage("No file is active at the moment. Open a file or click a pane that has a file open.");
            return null; // null indicates that getting a value has failed and the command should not be executed.
        }
        return file.name;
    }
}
addShellCommandVariableInstructions("{{file_name}}", "Gives the current file name with a file extension. If you need it without the extension, use {{title}} instead.");

class ShellCommandVariable_FolderPath extends ShellCommandVariable {
    constructor() {
        super(...arguments);
        this.name = "folder_path";
        this.parameters = {
            mode: {
                options: ["absolute", "relative"],
                required: true,
            }
        };
    }
    getValue() {
        let active_file = this.app.workspace.getActiveFile();
        if (active_file) {
            if (active_file.parent) {
                let folder = active_file.parent;
                switch (this.arguments.mode.toLowerCase()) {
                    case "absolute":
                        return normalizePath2(getVaultAbsolutePath(this.app) + "/" + folder.path);
                    case "relative":
                        if (folder.isRoot()) {
                            // Obsidian API does not give a correct folder.path value for the vault's root folder.
                            // TODO: See this discussion and apply possible changes if something will come up: https://forum.obsidian.md/t/vault-root-folders-relative-path-gives/24857
                            return ".";
                        }
                        else {
                            // This is a normal subfolder
                            return normalizePath2(folder.path); // Normalize to get a correct slash between directories depending on platform. On Windows it should be \ .
                        }
                }
            }
            else {
                this.newErrorMessage("The current file does not have a parent for some strange reason.");
                return null; // null indicates that getting a value has failed and the command should not be executed.
            }
        }
        else {
            this.newErrorMessage("No file is active at the moment. Open a file or click a pane that has a file open.");
            return null; // null indicates that getting a value has failed and the command should not be executed.
        }
    }
}
addShellCommandVariableInstructions("{{folder_path:relative}} or {{folder_path:absolute}}", "Gives path to the current file's parent folder, either as absolute from the root of the file system, or as relative from the root of the Obsidian vault.");

class ShellCommandVariable_Tags extends ShellCommandVariable {
    constructor() {
        super(...arguments);
        this.name = "tags";
        this.parameters = {
            separator: {
                type: "string",
                required: true,
            }
        };
    }
    getValue() {
        let active_file = this.app.workspace.getActiveFile();
        if (active_file) {
            // We do have an active file
            let cache = this.app.metadataCache.getFileCache(active_file);
            let tags = uniqueArray(obsidian.getAllTags(cache)); // If a tag is defined multiple times in the same file, getTags() returns it multiple times, so use uniqueArray() to iron out duplicates.
            // Remove preceding hash characters. E.g. #tag becomes tag
            tags.forEach((tag, index) => {
                tags[index] = tag.replace("#", "");
            });
            return tags.join(this.arguments.separator);
        }
        else {
            // No file is active at the moment
            this.newErrorMessage("No file is active at the moment. Open a file or click a pane that has a file open.");
            return null; // null indicates that getting a value has failed and the command should not be executed.
        }
    }
}
addShellCommandVariableInstructions("{{tags:separator}}", "Gives all tags defined in the current note. Replace the \"separator\" part with a comma, space or whatever characters you want to use as a separator between tags. A separator is always needed to be defined.");

class ShellCommandVariable_Title extends ShellCommandVariable {
    constructor() {
        super(...arguments);
        this.name = "title";
    }
    getValue() {
        let active_file = this.app.workspace.getActiveFile();
        if (active_file) {
            return active_file.basename;
        }
        this.newErrorMessage("No file is active at the moment. Open a file or click a pane that has a file open.");
        return null;
    }
}
addShellCommandVariableInstructions("{{title}}", "Gives the current file name without a file extension. If you need it with the extension, use {{file_name}} instead.");

class ShellCommandVariable_Workspace extends ShellCommandVariable {
    constructor() {
        super(...arguments);
        this.name = "workspace";
    }
    getValue() {
        var _a, _b, _c;
        // Idea how to access the workspaces plugin is copied 2021-09-15 from https://github.com/Vinzent03/obsidian-advanced-uri/blob/f7ef80d5252481242e69496208e925874209f4aa/main.ts#L168-L179
        // @ts-ignore internalPlugins exists although it's not in obsidian.d.ts.
        let workspaces_plugin = (_b = (_a = this.app.internalPlugins) === null || _a === void 0 ? void 0 : _a.plugins) === null || _b === void 0 ? void 0 : _b.workspaces;
        if (!workspaces_plugin) {
            this.newErrorMessage("Workspaces core plugin is not found for some reason. Please raise an issue in GitHub.");
            return null;
        }
        else if (!workspaces_plugin.enabled) {
            this.newErrorMessage("Workspaces core plugin is not enabled.");
            return null;
        }
        let workspace_name = (_c = workspaces_plugin.instance) === null || _c === void 0 ? void 0 : _c.activeWorkspace;
        if (!workspace_name) {
            this.newErrorMessage("Could not figure out the current workspace's name. Probably you have not loaded a workspace. You can do it e.g. via \"Manage workspaces\" from the left side panel.");
            return null;
        }
        // All ok
        return workspace_name;
    }
}
addShellCommandVariableInstructions("{{workspace}}", "Gives the current workspace's name, if the Workspaces core plugin is enabled.");

/**
 * @param plugin
 * @param command
 * @return string|string[] If parsing fails, an array of string error messages is returned. If the parsing succeeds, the parsed shell command will be returned just as a string, not in an array.
 */
function parseShellCommandVariables(plugin, command) {
    let shell_variables = [
        new ShellCommandVariable_Clipboard(plugin),
        new ShellCommandVariable_Date(plugin),
        new ShellCommandVariable_FileName(plugin),
        new ShellCommandVariable_FilePath(plugin),
        new ShellCommandVariable_FolderName(plugin),
        new ShellCommandVariable_FolderPath(plugin),
        new ShellCommandVariable_Selection(plugin),
        new ShellCommandVariable_Tags(plugin),
        new ShellCommandVariable_Title(plugin),
        new ShellCommandVariable_VaultPath(plugin),
        new ShellCommandVariable_Workspace(plugin),
    ];
    let parsed_command = command; // Create a copy of the variable because we don't want to alter the original value of 'command' during iterating its regex matches.
    for (let variable_index in shell_variables) {
        let variable = shell_variables[variable_index];
        let pattern = new RegExp(variable.getPattern(), "ig"); // i: case-insensitive; g: match all occurrences instead of just the first one.
        const parameter_names = variable.getParameterNames();
        let _arguments; // Need to prefix with _ because JavaScript reserves the variable name 'arguments'.
        while ((_arguments = pattern.exec(command)) !== null) {
            const substitute = _arguments.shift(); // '_arguments[0]' contains the whole match, not just an argument. Get it and remove it from '_arguments'.
            // Remove stuff that should not be iterated in the next loop.
            // "If the property which you are trying to delete does not exist, delete will not have any effect and will return true." This is good. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete
            delete _arguments["groups"];
            delete _arguments["index"];
            delete _arguments["input"];
            // Iterate all arguments
            for (let i in _arguments) {
                // Check that the argument is not omitted. It can be omitted (= undefined), if the parameter is optional.
                if (undefined !== _arguments[i]) {
                    // The argument is present.
                    const argument = _arguments[i].slice(1); // .slice(1): Remove a preceding :
                    const parameter_name = parameter_names[i];
                    variable.setArgument(parameter_name, argument);
                }
            }
            // Render the variable
            let variable_value = variable.getValue();
            if (variable.getErrorMessages().length) {
                // There has been a problem and executing the command should be cancelled.
                console.log("Parsing command " + command + " failed.");
                return variable.getErrorMessages(); // Returning now prevents parsing rest of the variables.
            }
            else {
                parsed_command = parsed_command.replace(substitute, variable_value);
            }
        }
    }
    return parsed_command;
}

function newShellCommandConfiguration(shell_command = "") {
    return {
        shell_command: shell_command,
        alias: "",
        confirm_execution: false,
        ignore_error_codes: [],
        output_channels: {
            stdout: "ignore",
            stderr: "notification",
        },
        output_channel_order: "stdout-first",
    };
}

function RunMigrations(plugin) {
    return __awaiter(this, void 0, void 0, function* () {
        let save = MigrateCommandsToShellCommands(plugin);
        save || (save = EnsureShellCommandsHaveAllFields(plugin));
        if (save) {
            // Only save if there were changes to configuration.
            console.log("Saving migrations...");
            yield plugin.saveSettings();
            console.log("Migrations saved...");
        }
    });
}
function MigrateCommandsToShellCommands(plugin) {
    let count_shell_commands = plugin.settings.commands.length;
    let save = false;
    if (0 < count_shell_commands) {
        let count_empty_commands = 0; // A counter for empty or null commands
        console.log("settings.commands is not empty, will migrate " + count_shell_commands + " commands to settings.shell_commands.");
        for (let shell_command_id in plugin.settings.commands) {
            let shell_command = plugin.settings.commands[shell_command_id];
            // Ensure that the command is not empty. Just in case.
            if (null === shell_command || 0 === shell_command.length) {
                // The command is empty
                console.log("Migration failure for shell command #" + shell_command_id + ": The original shell command string is empty, so it cannot be migrated.");
                count_empty_commands++;
            }
            else if (undefined !== plugin.settings.shell_commands[shell_command_id]) {
                // A command with the same id already exists
                console.log("Migration failure for shell command #" + shell_command_id + ": A shell command with same ID already exists in settings.shell_commands.");
            }
            else {
                // All OK, migrate.
                plugin.settings.shell_commands[shell_command_id] = newShellCommandConfiguration(shell_command); // Creates a shell command with default values and defines the command for it.
                delete plugin.settings.commands[shell_command_id]; // Leaves a null in place, but we can deal with it by deleting the whole array if it gets empty.
                count_empty_commands++; // Account the null generated on the previous line.
                save = true;
                console.log("Migrated shell command #" + shell_command_id + ": " + shell_command);
            }
        }
        if (count_empty_commands === count_shell_commands) {
            // The whole commands array now contains only empty/null commands.
            // Delete it.
            delete plugin.settings.commands;
        }
    }
    else {
        console.log("settings.commands is empty, so no need to migrate commands. Good thing! :)");
    }
    return save;
}
/**
 * This is a general migrator that adds new, missing properties to ShellCommandConfiguration objects. This is not tied to any specific version update, unlike MigrateCommandsToShellCommands().
 *
 * @param plugin
 * @constructor
 */
function EnsureShellCommandsHaveAllFields(plugin) {
    let save = false;
    let shell_command_default_configuration = newShellCommandConfiguration();
    let shell_command_id;
    let shell_command_configurations = plugin.getShellCommands();
    for (shell_command_id in shell_command_configurations) {
        let shell_command_configuration = shell_command_configurations[shell_command_id];
        for (let property_name in shell_command_default_configuration) {
            // @ts-ignore property_default_value can have (almost) whatever datatype
            let property_default_value = shell_command_default_configuration[property_name];
            // @ts-ignore
            if (undefined === shell_command_configuration[property_name]) {
                // This shell command does not have this property.
                // Add the property to the shell command and use a default value.
                console.log("EnsureShellCommandsHaveAllFields(): Shell command #" + shell_command_id + " does not have property '" + property_name + "'. Will create the property and assign a default value '" + property_default_value + "'.");
                // @ts-ignore
                shell_command_configuration[property_name] = property_default_value;
                save = true;
            }
        }
    }
    return save;
}

const DEFAULT_SETTINGS = {
    working_directory: "",
    preview_variables_in_command_palette: true,
    shell_commands: {},
    error_message_duration: 20,
    notification_message_duration: 10,
    // Legacy:
    commands: [] // Deprecated, but must be present in the default values as long as migrating from commands to shell_commands is supported.
};

class OutputChannelDriver {
    /**
     * Can be overridden in child classes in order to vary the title depending on output_stream.
     * @param output_stream
     */
    getTitle(output_stream) {
        return this.title;
    }
    initialize(plugin) {
        this.plugin = plugin;
        this.app = plugin.app;
    }
}

class OutputChannelDriver_Notification extends OutputChannelDriver {
    getTitle(output_stream) {
        switch (output_stream) {
            case "stdout":
                return "Notification balloon";
            case "stderr":
                return "Error balloon";
        }
    }
    handle(output, error_code) {
        // Iterate output streams.
        // There can be both "stdout" and "stderr" present at the same time, or just one of them. If both are present, two
        // notifications will be created.
        let output_stream_name;
        for (output_stream_name in output) {
            let output_message = output[output_stream_name];
            switch (output_stream_name) {
                case "stdout":
                    // Normal output
                    this.plugin.newNotification(output_message);
                    break;
                case "stderr":
                    // Error output
                    this.plugin.newError("[" + error_code + "]: " + output_message);
                    break;
            }
        }
    }
}

class OutputChannelDriver_CurrentFile extends OutputChannelDriver {
    handle(output) {
        let editor = getEditor(this.app);
        let view = getView(this.app);
        // There can be both "stdout" and "stderr" present at the same time, or just one of them. If both are present, they
        // will be joined together with " " as a separator.
        let output_message = joinObjectProperties(output, " ");
        if (null === editor) {
            // For some reason it's not possible to get an editor.
            this.plugin.newError("Could not get an editor instance! Please raise an issue in GitHub. The command output is in the next error box:");
            this.plugin.newError(output_message); // Good to output it at least some way.
            console.log("OutputChannelDriver_CurrentFile: Could not get an editor instance.");
            return;
        }
        // Check if the view is in source mode
        if (null === view) {
            // For some reason it's not possible to get an editor, but it's not a big problem.
            console.log("OutputChannelDriver_CurrentFile: Could not get a view instance.");
        }
        else {
            // We do have a view
            if ("source" !== view.getMode()) {
                // Warn that the output might go to an unexpected place in the note file.
                this.plugin.newNotification("Note that your active note is not in 'Edit' mode! The output comes visible when you switch to 'Edit' mode again!");
            }
        }
        // Insert into the current file
        this.insertIntoEditor(editor, output_message);
    }
}

class OutputChannelDriver_CurrentFileCaret extends OutputChannelDriver_CurrentFile {
    constructor() {
        super(...arguments);
        this.title = "Current file: caret position";
    }
    /**
     * Inserts text into the given editor, at caret position.
     *
     * @param editor
     * @param output_message
     * @protected
     */
    insertIntoEditor(editor, output_message) {
        editor.replaceSelection(output_message);
    }
}

class OutputChannelDriver_CurrentFileTop extends OutputChannelDriver_CurrentFile {
    constructor() {
        super(...arguments);
        this.title = "Current file: top";
    }
    /**
     * Inserts text into the given editor, at top.
     *
     * @param editor
     * @param output_message
     * @protected
     */
    insertIntoEditor(editor, output_message) {
        const top_position = editor.offsetToPos(0);
        editor.replaceRange(output_message, top_position);
    }
}

class OutputChannelDriver_StatusBar extends OutputChannelDriver {
    constructor() {
        super(...arguments);
        this.title = "Status bar";
    }
    handle(output) {
        const status_bar_element = this.getStatusBarElement();
        // Combine stdout and stderr (in case both of them happen to be present).
        let stdout_and_stderr = joinObjectProperties(output, os.EOL + os.EOL).trim();
        // Full output (shown when hovering with mouse)
        status_bar_element.setAttr("aria-label", stdout_and_stderr);
        // Show last line permanently.
        const output_message_lines = stdout_and_stderr.split(/(\r\n|\r|\n)/);
        const last_output_line = output_message_lines[output_message_lines.length - 1];
        status_bar_element.setText(last_output_line);
    }
    getStatusBarElement() {
        if (!this.status_bar_element) {
            this.status_bar_element = this.plugin.addStatusBarItem();
        }
        return this.status_bar_element;
    }
}

class OutputChannelDriver_CurrentFileBottom extends OutputChannelDriver_CurrentFile {
    constructor() {
        super(...arguments);
        this.title = "Current file: bottom";
    }
    /**
     * Inserts text into the given editor, at bottom.
     *
     * @param editor
     * @param output_message
     * @protected
     */
    insertIntoEditor(editor, output_message) {
        const bottom_position = {
            ch: editor.getLine(editor.lastLine()).length,
            line: editor.lastLine(), // ... the last line.
        }; // *) But do not subtract 1, because ch is zero-based, so when .length is used without -1, we are pointing AFTER the last character.
        editor.replaceRange(output_message, bottom_position);
    }
}

class OutputChannelDriver_Clipboard extends OutputChannelDriver {
    constructor() {
        super(...arguments);
        this.title = "Clipboard";
    }
    handle(output) {
        // There can be both "stdout" and "stderr" present at the same time, or just one of them. If both are present, they
        // will be joined together with " " as a separator.
        let output_message = joinObjectProperties(output, " ");
        electron.clipboard.writeText(output_message);
        // Notify the user so they know a) what was copied to clipboard, and b) that their command has finished execution.
        this.plugin.newNotification("Copied to clipboard: " + os.EOL + output_message);
    }
}

let output_channel_drivers = {};
// Register output channel drivers
registerOutputChannelDriver("status-bar", new OutputChannelDriver_StatusBar());
registerOutputChannelDriver("notification", new OutputChannelDriver_Notification());
registerOutputChannelDriver("current-file-caret", new OutputChannelDriver_CurrentFileCaret());
registerOutputChannelDriver("current-file-top", new OutputChannelDriver_CurrentFileTop());
registerOutputChannelDriver("current-file-bottom", new OutputChannelDriver_CurrentFileBottom());
registerOutputChannelDriver("clipboard", new OutputChannelDriver_Clipboard());
function handleShellCommandOutput(plugin, shell_command_configuration, stdout, stderr, error_code) {
    // Terminology: Stream = outputs stream from a command, can be "stdout" or "stderr". Channel = a method for this application to present the output ot user, e.g. "notification".
    // Insert stdout and stderr to an object in a correct order
    let output = {};
    if (stdout.length && stderr.length) {
        // Both stdout and stderr have content
        // Decide the output order == Find out which data stream should be processed first, stdout or stderr.
        switch (shell_command_configuration.output_channel_order) {
            case "stdout-first":
                output = {
                    stdout: stdout,
                    stderr: stderr,
                };
                break;
            case "stderr-first":
                output = {
                    stderr: stderr,
                    stdout: stdout,
                };
                break;
        }
    }
    else if (stdout.length) {
        // Only stdout has content
        output = {
            stdout: stdout,
        };
    }
    else if (stderr.length) {
        // Only stderr has content
        output = {
            stderr: stderr,
        };
    }
    else {
        // Neither stdout nor stderr have content
        // Do nothing
        return;
    }
    // Should stderr be processed same time with stdout?
    if (shell_command_configuration.output_channels.stdout === shell_command_configuration.output_channels.stderr) {
        // Stdout and stderr use the same channel.
        // Make one handling call.
        handle_stream(plugin, shell_command_configuration, shell_command_configuration.output_channels.stdout, output, error_code);
    }
    else {
        // Stdout and stderr use different channels.
        // Make two handling calls.
        let output_stream_name;
        for (output_stream_name in output) {
            let output_channel_name = shell_command_configuration.output_channels[output_stream_name];
            let output_message = output[output_stream_name];
            let separated_output = {};
            separated_output[output_stream_name] = output_message;
            handle_stream(plugin, shell_command_configuration, output_channel_name, separated_output, error_code);
        }
    }
}
function handle_stream(plugin, shell_command_configuration, output_channel_name, output, error_code) {
    // Check if the output should be ignored
    if ("ignore" !== output_channel_name) {
        // The output should not be ignored.
        // Check that an output driver exists
        if (undefined === output_channel_drivers[output_channel_name]) {
            throw new Error("No output driver found for channel '" + output_channel_name + "'.");
        }
        let driver = output_channel_drivers[output_channel_name];
        // Perform handling the output
        driver.initialize(plugin);
        driver.handle(output, error_code);
    }
}
function getOutputChannelDriversOptionList(output_stream) {
    let list = { ignore: "Ignore" };
    for (let name in output_channel_drivers) {
        list[name] = output_channel_drivers[name].getTitle(output_stream);
    }
    return list;
}
function registerOutputChannelDriver(name, driver) {
    if (undefined !== output_channel_drivers[name]) {
        throw new Error("OutputChannelDriver named '" + name + "' is already registered!");
    }
    output_channel_drivers[name] = driver;
}

class ShellCommandExtraOptionsModal extends obsidian.Modal {
    constructor(app, plugin, shell_command_id, setting_group, setting_tab) {
        super(app);
        this.plugin = plugin;
        this.shell_command_id = shell_command_id;
        this.shell_command_configuration = plugin.getShellCommands()[shell_command_id];
        this.name_setting = setting_group.name_setting;
        this.setting_tab = setting_tab;
    }
    onOpen() {
        this.modalEl.createEl("h2", { text: this.shell_command_configuration.shell_command });
        // Alias field
        new obsidian.Setting(this.modalEl)
            .setName("Alias")
            .setClass("shell-commands-name-setting");
        let alias_setting = new obsidian.Setting(this.modalEl)
            .addText(text => text
            .setValue(this.shell_command_configuration.alias)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            // Change the actual alias value
            this.shell_command_configuration.alias = value;
            // Update Obsidian command palette
            this.plugin.obsidian_commands[this.shell_command_id].name = this.plugin.generateObsidianCommandName(this.shell_command_configuration);
            // UpdateShell commands settings panel
            this.name_setting.setName(this.setting_tab.generateCommandFieldName(this.shell_command_id, this.shell_command_configuration));
            // Save
            yield this.plugin.saveSettings();
        })))
            .setClass("shell-commands-shell-command-setting");
        alias_setting.controlEl.find("input").focus(); // Focus without a need to click the field.
        this.modalEl.createEl("p", { text: "If not empty, the alias will be displayed in the command palette instead of the actual command. An alias is never executed as a command." });
        this.modalEl.createEl("p", { text: "You can also use the same {{}} style variables in aliases that are used in shell commands. When variables are used in aliases, they do not affect the command execution in any way, but it's a nice way to reveal what values your command will use, even when an alias hides most of the other technical details." });
        // Confirm execution field
        new obsidian.Setting(this.modalEl)
            .setName("Ask confirmation before execution")
            .addToggle(toggle => toggle
            .setValue(this.shell_command_configuration.confirm_execution)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            this.shell_command_configuration.confirm_execution = value;
            let icon_container = this.name_setting.nameEl.find("span.shell-commands-confirm-execution-icon-container");
            if (this.shell_command_configuration.confirm_execution) {
                // Show icon
                icon_container.removeClass("shell-commands-hide");
            }
            else {
                // Hide icon
                icon_container.addClass("shell-commands-hide");
            }
            yield this.plugin.saveSettings();
        })));
        // Output channeling
        this.newOutputChannelSetting("Output channel for stdout", "stdout");
        this.newOutputChannelSetting("Output channel for stderr", "stderr", "If both stdout and stderr use the same channel, stderr will be combined to same message with stdout.");
        new obsidian.Setting(this.modalEl)
            .setName("Order of stdout/stderr output")
            .setDesc("When output contains both errors and normal output, which one should be presented first?")
            .addDropdown(dropdown => dropdown
            .addOptions({
            "stdout-first": "Stdout first, then stderr.",
            "stderr-first": "Stderr first, then stdout.",
        })
            .setValue(this.shell_command_configuration.output_channel_order)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            this.shell_command_configuration.output_channel_order = value;
            yield this.plugin.saveSettings();
        })));
        // Ignore errors field
        new obsidian.Setting(this.modalEl)
            .setName("Ignore error codes")
            .setDesc("A comma separated list of numbers. If executing a shell command fails with one of these exit codes, no error message will be displayed, and the above stderr channel will be ignored. Stdout channel will still be used for stdout. Error codes must be integers and greater than or equal to 1. Anything else will be removed.")
            .addText(text => text
            .setValue(this.shell_command_configuration.ignore_error_codes.join(","))
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            // Parse the string of comma separated numbers
            let ignore_error_codes = [];
            let raw_error_codes = value.split(",");
            for (let i in raw_error_codes) {
                let raw_error_code = raw_error_codes[i];
                let error_code_candidate = parseInt(raw_error_code.trim()); // E.g. an empty string converts to NaN (= Not a Number).
                // Ensure that the error code is not NaN, 0 or a negative number.
                if (!isNaN(error_code_candidate) && error_code_candidate >= 1) {
                    // The candidate is legit.
                    ignore_error_codes.push(error_code_candidate);
                }
            }
            // Save the validated error numbers
            this.shell_command_configuration.ignore_error_codes = ignore_error_codes;
            yield this.plugin.saveSettings();
            // Update icon
            let icon_container = this.name_setting.nameEl.find("span.shell-commands-ignored-error-codes-icon-container");
            if (this.shell_command_configuration.ignore_error_codes.length) {
                // Show icon
                icon_container.setAttr("aria-label", this.setting_tab.generateIgnoredErrorCodesIconTitle(this.shell_command_configuration.ignore_error_codes));
                icon_container.removeClass("shell-commands-hide");
            }
            else {
                // Hide icon
                icon_container.addClass("shell-commands-hide");
            }
        })));
    }
    newOutputChannelSetting(title, output_stream_name, description = "") {
        let output_channel_options = getOutputChannelDriversOptionList(output_stream_name);
        new obsidian.Setting(this.modalEl)
            .setName(title)
            .setDesc(description)
            .addDropdown(dropdown => dropdown
            .addOptions(output_channel_options)
            .setValue(this.shell_command_configuration.output_channels[output_stream_name])
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            this.shell_command_configuration.output_channels[output_stream_name] = value;
            yield this.plugin.saveSettings();
        })));
    }
}
ShellCommandExtraOptionsModal.OPTIONS_SUMMARY = "Alias, Output, Confirmation, Ignore errors";

class ShellCommandDeleteModal extends obsidian.Modal {
    constructor(plugin, shell_command_id, setting_group, container_element) {
        super(plugin.app);
        this.plugin = plugin;
        this.shell_command_id = shell_command_id;
        this.shell_command_configuration = plugin.getShellCommands()[shell_command_id];
        this.setting_group = setting_group;
        this.container_element = container_element;
    }
    onOpen() {
        this.modalEl.createEl("h2", { text: "Delete: " + this.shell_command_configuration.shell_command });
        if (this.shell_command_configuration.alias) {
            this.modalEl.createEl("p", { text: "Alias: " + this.shell_command_configuration.alias });
        }
        this.modalEl.createEl("p", { text: "Are you sure you want to delete this shell command?" });
        let delete_button = this.modalEl.createEl("button", { text: "Yes, delete" });
        delete_button.onclick = () => __awaiter(this, void 0, void 0, function* () {
            // Remove the command
            console.log("Command " + this.shell_command_id + " gonna be removed.");
            delete this.plugin.getShellCommands()[this.shell_command_id]; // Remove from the plugin's settings.
            delete this.plugin.obsidian_commands[this.shell_command_id]; // Remove from the command palette.
            // Remove the setting fields
            this.container_element.removeChild(this.setting_group.name_setting.settingEl);
            this.container_element.removeChild(this.setting_group.shell_command_setting.settingEl);
            this.container_element.removeChild(this.setting_group.preview_setting.settingEl);
            yield this.plugin.saveSettings();
            console.log("Command removed.");
            this.close();
        });
    }
}

function getHotkeysForShellCommand(plugin, shell_command_id) {
    var _a, _b;
    // Retrieve all hotkeys set by user.
    // @ts-ignore
    let app_custom_hotkeys = (_a = plugin.app.hotkeyManager) === null || _a === void 0 ? void 0 : _a.customKeys;
    if (!app_custom_hotkeys) {
        console.log("getHotkeysForShellCommand() failed, will return an empty array.");
        return [];
    }
    // Get only our hotkeys.
    let hotkey_index = plugin.getPluginId() + ":" + plugin.generateObsidianCommandId(shell_command_id); // E.g. "obsidian-shellcommands:shell-command-0"
    console.log("getHotkeysForShellCommand() succeeded.");
    return (_b = app_custom_hotkeys[hotkey_index]) !== null && _b !== void 0 ? _b : []; // If no hotkey array is set for this command, return an empty array. Although I do believe that all commands do have an array anyway, but have this check just in case.
}
/**
 * TODO: Is there a way to make Obsidian do this conversion for us?
 *
 * @param hotkey
 * @constructor
 */
function HotkeyToString(hotkey) {
    let keys = [];
    hotkey.modifiers.forEach((modifier) => {
        let modifier_key = modifier.toString(); // This is one of 'Mod' | 'Ctrl' | 'Meta' | 'Shift' | 'Alt'
        if ("Mod" === modifier_key) {
            // Change "Mod" to something more meaningful.
            modifier_key = obsidian.Platform.isMacOS ? "Cmd" : "Ctrl"; // isMacOS should also be true if the device is iPhone/iPad. Can be handy if this plugin gets mobile support some day.
        }
        keys.push(modifier_key);
    });
    keys.push(hotkey.key); // This is something like a letter ('A', 'B' etc) or space/enter/whatever.
    return keys.join(" + ");
}

class ShellCommandsSettingsTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.scroll_position = 0;
        this.plugin = plugin;
    }
    display() {
        let { containerEl } = this;
        containerEl.empty();
        containerEl.createEl('h2', { text: "Shell commands" });
        // "Working directory" field
        new obsidian.Setting(containerEl)
            .setName("Working directory")
            .setDesc("A directory where your commands will be run. If empty, defaults to your vault's location. Can be relative (= a folder in the vault) or absolute (= complete from filesystem root).")
            .addText(text => text
            .setPlaceholder(getVaultAbsolutePath(this.app))
            .setValue(this.plugin.settings.working_directory)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            console.log("Changing working_directory to " + value);
            this.plugin.settings.working_directory = value;
            yield this.plugin.saveSettings();
        })));
        // A <div> element for all command input fields. New command fields can be created at the bottom of this element.
        let command_fields_container = containerEl.createEl("div");
        // Fields for modifying existing commands
        for (let command_id in this.plugin.getShellCommands()) {
            this.createCommandField(command_fields_container, command_id);
        }
        // "New command" button
        new obsidian.Setting(containerEl)
            .addButton(button => button
            .setButtonText("New command")
            .onClick(() => __awaiter(this, void 0, void 0, function* () {
            this.createCommandField(command_fields_container, "new");
            console.log("New empty command created.");
        })));
        // "Error message duration" field
        this.createNotificationDurationField(containerEl, "Error message duration", "Concerns messages about failed shell commands.", "error_message_duration");
        // "Notification message duration" field
        this.createNotificationDurationField(containerEl, "Notification message duration", "Concerns informational, non fatal messages, e.g. output directed to 'Notification balloon'.", "notification_message_duration");
        // "Variables" section
        containerEl.createEl("h2", { text: "Variables" });
        // "Preview variables in command palette" field
        new obsidian.Setting(containerEl)
            .setName("Preview variables in command palette")
            .setDesc("If on, variable names are substituted with their realtime values when you view your commands in the command palette. A nice way to ensure your commands will use correct values.")
            .addToggle(checkbox => checkbox
            .setValue(this.plugin.settings.preview_variables_in_command_palette)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            console.log("Changing preview_variables_in_command_palette to " + value);
            this.plugin.settings.preview_variables_in_command_palette = value;
            if (!value) {
                // Variable previewing is turned from on to off.
                // This means that the command palette may have old, stale variable data in it (if a user has opened the palette, but closed it without executing anything).
                // Remove old, preparsed variable data and reset shell commands' names in the command palette.
                this.plugin.resetPreparsedShellCommandConfigurations();
                this.plugin.resetCommandPaletteNames();
            }
            yield this.plugin.saveSettings();
        })));
        // Variable instructions
        getShellCommandVariableInstructions().forEach((instructions) => {
            let paragraph = containerEl.createEl("p");
            // @ts-ignore
            paragraph.createEl("strong", { text: instructions.variable_name + " " });
            // @ts-ignore
            paragraph.createEl("span", { text: instructions.instructions });
        });
        containerEl.createEl("p", { text: "When you type variables into commands, a preview text appears under the command field to show how the command will look like when it gets executed with variables substituted with their real values." });
        containerEl.createEl("p", { text: "There is no way to escape variable parsing. If you need {{ }} characters in your command, they won't be parsed as variables as long as they do not contain any of the variable names listed below. If you would need to pass e.g. {{title}} literally to your command, there is no way to do it atm, please raise an issue in GitHub." });
        containerEl.createEl("p", { text: "All variables that access the current file, may cause the command preview to fail if you had no file panel active when you opened the settings window - e.g. you had focus on graph view instead of a note = no file is currently active. But this does not break anything else than the preview." });
        // KEEP THIS AFTER CREATING ALL ELEMENTS:
        this.rememberScrollPosition(containerEl);
    }
    /**
     *
     * @param container_element
     * @param shell_command_id Either a string formatted integer ("0", "1" etc) or "new" if it's a field for a command that does not exist yet.
     */
    createCommandField(container_element, shell_command_id) {
        let is_new = "new" === shell_command_id;
        let shell_command_configuration;
        if (is_new) {
            // Create an empty command
            shell_command_id = this.plugin.generateNewShellCommandID();
            shell_command_configuration = newShellCommandConfiguration();
            this.plugin.getShellCommands()[shell_command_id] = shell_command_configuration;
            // Register the empty shell command to Obsidian's command palette.
            // Do it already now, because there are settings (e.g. Alias) that, when changed by the user, will try to modify the Obsidian command. Sometimes users edit these settings before writing the actual command. See issue #46: https://github.com/Taitava/obsidian-shellcommands/issues/46
            this.plugin.registerShellCommand(shell_command_id, shell_command_configuration);
        }
        else {
            // Use an old shell command
            shell_command_configuration = this.plugin.getShellCommands()[shell_command_id];
        }
        console.log("Create command field for command #" + shell_command_id + (is_new ? " (NEW)" : ""));
        let shell_command;
        if (is_new) {
            shell_command = "";
        }
        else {
            shell_command = shell_command_configuration.shell_command;
        }
        let setting_group = {
            name_setting: new obsidian.Setting(container_element)
                .setName(this.generateCommandFieldName(shell_command_id, this.plugin.getShellCommands()[shell_command_id]))
                .addExtraButton(button => button
                .setTooltip("Execute now")
                .setIcon("run-command")
                .onClick(() => {
                // Execute the shell command now (for trying it out in the settings)
                let shell_command_configuration = this.plugin.getShellCommands()[shell_command_id];
                let parsed_shell_command = parseShellCommandVariables(this.plugin, shell_command_configuration.shell_command);
                if (Array.isArray(parsed_shell_command)) {
                    this.plugin.newErrors(parsed_shell_command);
                }
                else {
                    this.plugin.confirmAndExecuteShellCommand(parsed_shell_command, shell_command_configuration);
                }
            }))
                .addExtraButton(button => button
                .setTooltip(ShellCommandExtraOptionsModal.OPTIONS_SUMMARY)
                .onClick(() => __awaiter(this, void 0, void 0, function* () {
                // Open an extra options modal
                let modal = new ShellCommandExtraOptionsModal(this.app, this.plugin, shell_command_id, setting_group, this);
                modal.open();
            })))
                .addExtraButton(button => button
                .setTooltip("Delete this shell command")
                .setIcon("trash")
                .onClick(() => __awaiter(this, void 0, void 0, function* () {
                // Open a delete modal
                let modal = new ShellCommandDeleteModal(this.plugin, shell_command_id, setting_group, container_element);
                modal.open();
            })))
                .setClass("shell-commands-name-setting"),
            shell_command_setting: new obsidian.Setting(container_element)
                .addText(text => text
                .setPlaceholder("Enter your command")
                .setValue(shell_command)
                .onChange((field_value) => __awaiter(this, void 0, void 0, function* () {
                let shell_command = field_value;
                setting_group.preview_setting.setDesc(this.getShellCommandPreview(shell_command));
                if (is_new) {
                    console.log("Creating new command " + shell_command_id + ": " + shell_command);
                }
                else {
                    console.log("Command " + shell_command_id + " gonna change to: " + shell_command);
                }
                // Do this in both cases, when creating a new command and when changing an old one:
                shell_command_configuration.shell_command = shell_command;
                if (is_new) {
                    // Create a new command
                    this.plugin.registerShellCommand(shell_command_id, shell_command_configuration);
                    console.log("Command created.");
                }
                else {
                    // Change an old command
                    this.plugin.obsidian_commands[shell_command_id].name = this.plugin.generateObsidianCommandName(this.plugin.getShellCommands()[shell_command_id]); // Change the command's name in Obsidian's command palette.
                    console.log("Command changed.");
                }
                yield this.plugin.saveSettings();
            })))
                .setClass("shell-commands-shell-command-setting"),
            preview_setting: new obsidian.Setting(container_element)
                .setDesc(this.getShellCommandPreview(shell_command))
                .setClass("shell-commands-preview-setting"),
        };
        // Informational icons (= non-clickable)
        let icon_container = setting_group.name_setting.nameEl.createEl("span", { attr: { class: "shell-commands-main-icon-container" } });
        // "Ask confirmation" icon.
        let confirm_execution_icon_container = icon_container.createEl("span", { attr: { "aria-label": "Asks confirmation before execution.", class: "shell-commands-confirm-execution-icon-container" } });
        obsidian.setIcon(confirm_execution_icon_container, "languages");
        if (!shell_command_configuration.confirm_execution) {
            // Do not display the icon for commands that do not use confirmation.
            confirm_execution_icon_container.addClass("shell-commands-hide");
        }
        // "Ignored error codes" icon
        let ignored_error_codes_icon_container = icon_container.createEl("span", { attr: { "aria-label": this.generateIgnoredErrorCodesIconTitle(shell_command_configuration.ignore_error_codes), class: "shell-commands-ignored-error-codes-icon-container" } });
        obsidian.setIcon(ignored_error_codes_icon_container, "strikethrough-glyph");
        if (!shell_command_configuration.ignore_error_codes.length) {
            // Do not display the icon for commands that do not ignore any errors.
            ignored_error_codes_icon_container.addClass("shell-commands-hide");
        }
        // Add hotkey information
        if (!is_new) {
            let hotkeys = getHotkeysForShellCommand(this.plugin, shell_command_id);
            if (hotkeys) {
                let hotkeys_joined = "";
                hotkeys.forEach((hotkey) => {
                    if (hotkeys_joined) {
                        hotkeys_joined += "<br>";
                    }
                    hotkeys_joined += HotkeyToString(hotkey);
                });
                let hotkey_div = setting_group.preview_setting.controlEl.createEl("div", { attr: { class: "setting-item-description shell-commands-hotkey-info" } });
                // Comment out the icon because it would look like a clickable button (as there are other clickable icons in the settings).
                // setIcon(hotkey_div, "any-key", 22); // Hotkey icon
                hotkey_div.insertAdjacentHTML("beforeend", " " + hotkeys_joined);
            }
        }
        console.log("Created.");
    }
    createNotificationDurationField(container_element, title, description, setting_name) {
        new obsidian.Setting(container_element)
            .setName(title)
            .setDesc(description + " In seconds, between 1 and 180.")
            .addText(field => field
            .setValue(String(this.plugin.settings[setting_name]))
            .onChange((duration_string) => __awaiter(this, void 0, void 0, function* () {
            let duration = parseInt(duration_string);
            if (duration >= 1 && duration <= 180) {
                console.log("Change " + setting_name + " from " + this.plugin.settings[setting_name] + " to " + duration);
                this.plugin.settings[setting_name] = duration;
                yield this.plugin.saveSettings();
                console.log("Changed.");
            }
            // Don't show a notice if duration is not between 1 and 180, because this function is called every time a user types in this field, so the value might not be final.
        })));
    }
    getShellCommandPreview(shell_command) {
        let parsed_shell_command = parseShellCommandVariables(this.plugin, shell_command); // false: disables notifications if variables have syntax errors.
        if (Array.isArray(parsed_shell_command)) {
            // Variable parsing failed.
            // Return just the first error message, even if there are multiple errors, because the preview space is limited.
            return parsed_shell_command[0];
        }
        // Variable parsing succeeded
        return parsed_shell_command;
    }
    rememberScrollPosition(container_element) {
        container_element.scrollTo({
            top: this.scroll_position,
            behavior: "auto",
        });
        container_element.addEventListener("scroll", (event) => {
            this.scroll_position = container_element.scrollTop;
        });
    }
    /**
     * @param shell_command_id String like "0" or "1" etc.
     * @param shell_command_configuration
     * @public Public because ShellCommandExtraOptionsModal uses this too.
     */
    generateCommandFieldName(shell_command_id, shell_command_configuration) {
        if (shell_command_configuration.alias) {
            return shell_command_configuration.alias;
        }
        return "Command #" + shell_command_id;
    }
    /**
     * @param ignored_error_codes
     * @public Public because ShellCommandExtraOptionsModal uses this too.
     */
    generateIgnoredErrorCodesIconTitle(ignored_error_codes) {
        let plural = ignored_error_codes.length !== 1 ? "s" : "";
        return "Ignored error" + plural + ": " + ignored_error_codes.join(",");
    }
}

class ConfirmExecutionModal extends obsidian.Modal {
    constructor(plugin, shell_command, shell_command_configuration) {
        super(plugin.app);
        this.plugin = plugin;
        this.shell_command = shell_command;
        this.shell_command_configuration = shell_command_configuration;
    }
    open() {
        super.open();
        // Information about the shell command
        this.modalEl.createEl("h2", { text: this.shell_command, attr: { style: "margin-bottom: 0;" } });
        if (this.shell_command_configuration.alias) {
            this.modalEl.createEl("p", { text: "Alias: " + this.shell_command_configuration.alias, attr: { style: "margin-top: 0;" } });
        }
        this.modalEl.createEl("p", { text: "Execute this shell command?" });
        // Execute button
        new obsidian.Setting(this.modalEl)
            .addButton(button => button
            .setButtonText("Yes, execute!")
            .onClick(() => {
            console.log("User confirmed execution of shell command: " + this.shell_command);
            this.plugin.executeShellCommand(this.shell_command, this.shell_command_configuration);
            this.close();
        }));
    }
}

class ShellCommandsPlugin extends obsidian.Plugin {
    constructor() {
        super(...arguments);
        this.obsidian_commands = {};
        /**
         * Temporary holder for ShellCommandConfigurations whose variables are already parsed before the actual execution during command palette preview.
         * This array gets emptied after every shell command execution.
         *
         * @private
         */
        this.preparsed_shell_command_configurations = {};
    }
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('loading plugin');
            yield this.loadSettings();
            // Run possible configuration migrations
            yield RunMigrations(this);
            // Make all defined shell commands to appear in the Obsidian command list
            let shell_commands = this.getShellCommands();
            for (let command_id in shell_commands) {
                let shell_command_configuration = shell_commands[command_id];
                this.registerShellCommand(command_id, shell_command_configuration);
            }
            this.addSettingTab(new ShellCommandsSettingsTab(this.app, this));
        });
    }
    getShellCommands() {
        return this.settings.shell_commands;
    }
    /**
     *
     * @param command_id string, but in practise it's a number in a string format, e.g. "0" or "1" etc.
     * @param shell_command_configuration
     */
    registerShellCommand(command_id, shell_command_configuration) {
        console.log("Registering shell command #" + command_id + " (" + shell_command_configuration.shell_command + ") to Obsidian...");
        let obsidian_command = {
            id: this.generateObsidianCommandId(command_id),
            name: this.generateObsidianCommandName(shell_command_configuration),
            // Use 'checkCallback' instead of normal 'callback' because we also want to get called when the command palette is opened.
            checkCallback: (is_opening_command_palette) => {
                if (is_opening_command_palette) {
                    // The user is currently opening the command palette.
                    // Do not execute the command yet, but parse variables for preview, if enabled in the settings.
                    if (this.settings.preview_variables_in_command_palette) {
                        let preparsed_shell_command_configuration = cloneObject(shell_command_configuration); // Clone shell_command_configuration so that we won't edit the original object.
                        // Parse variables in the actual shell command
                        let parsed_shell_command = parseShellCommandVariables(this, preparsed_shell_command_configuration.shell_command);
                        if (Array.isArray(parsed_shell_command)) {
                            // Variable parsing failed, because an array was returned, which contains error messages.
                            // Just cancel the preview, the command will be shown with variable names. Discard the error messages.
                            console.log("Shell command preview: Variable parsing failed for shell command " + preparsed_shell_command_configuration.shell_command);
                            return true;
                        }
                        else {
                            // Variable parsing succeeded.
                            // Use the parsed values.
                            preparsed_shell_command_configuration.shell_command = parsed_shell_command;
                        }
                        // Also parse variables in an alias, in case the command has one. Variables in aliases do not do anything practical, but they can reveal the user what variables are used in the command.
                        let parsed_alias = parseShellCommandVariables(this, preparsed_shell_command_configuration.alias);
                        if (Array.isArray(parsed_alias)) {
                            // Variable parsing failed, because an array was returned, which contains error messages.
                            // Just cancel the preview, the alias will be shown with variable names. Discard the error messages.
                            console.log("Shell command preview: Variable parsing failed for alias " + preparsed_shell_command_configuration.alias);
                            return true;
                        }
                        else {
                            // Variable parsing succeeded.
                            // Use the parsed values.
                            preparsed_shell_command_configuration.alias = parsed_alias;
                        }
                        // Rename the command in command palette
                        let prefix = this.getPluginName() + ": "; // Normally Obsidian prefixes all commands with the plugin name automatically, but now that we are actually _editing_ a command in the palette (not creating a new one), Obsidian won't do the prefixing for us.
                        obsidian_command.name = prefix + this.generateObsidianCommandName(preparsed_shell_command_configuration);
                        // Store the preparsed shell command so that we can use exactly the same values if the command gets later executed.
                        this.preparsed_shell_command_configurations[command_id] = preparsed_shell_command_configuration;
                    }
                    return true; // Need to return true, otherwise the command would be left out from the command palette.
                }
                else {
                    // The user has instructed to execute the command.
                    // Check if we happen to have a preparsed command (= variables parsed at the time of opening the command palette)
                    if (undefined === this.preparsed_shell_command_configurations[command_id]) {
                        // No preparsed command. Execute a standard version of the command, and do variable parsing now.
                        let parsed_shell_command = parseShellCommandVariables(this, shell_command_configuration.shell_command);
                        if (Array.isArray(parsed_shell_command)) {
                            // The command could not be parsed correctly.
                            // Display error messages
                            this.newErrors(parsed_shell_command);
                        }
                        else {
                            // The command was parsed correctly.
                            this.confirmAndExecuteShellCommand(parsed_shell_command, shell_command_configuration);
                        }
                    }
                    else {
                        // We do have a preparsed version of this command.
                        // No need to check if the parsing had previously succeeded, because if it would have failed, the command would not be in the preparsed commands' array.
                        this.confirmAndExecuteShellCommand(this.preparsed_shell_command_configurations[command_id].shell_command, shell_command_configuration);
                    }
                    // Delete the whole array of preparsed commands. Even though we only used just one command from it, we need to notice that opening a command
                    // palette might generate multiple preparsed commands in the array, but as the user selects and executes only one command, all these temporary
                    // commands are now obsolete. Delete them just in case the user toggles the variable preview feature off in the settings. We do not want to
                    // execute obsolete commands accidentally. This deletion also needs to be done even if the executed command was not a preparsed command, because
                    // even when preparsing is turned on in the settings, singular commands may fail to parse and therefore they would not be in this array, but other
                    // commands might be.
                    this.resetPreparsedShellCommandConfigurations();
                }
            }
        };
        this.addCommand(obsidian_command);
        this.obsidian_commands[command_id] = obsidian_command; // Store the reference so that we can edit the command later in ShellCommandsSettingsTab if needed.
        console.log("Registered.");
    }
    /**
     * Called when it's known that preparsed shell command variables have old data and should not be used later.
     */
    resetPreparsedShellCommandConfigurations() {
        this.preparsed_shell_command_configurations = {};
    }
    /**
     * Called after turning "Preview variables in command palette" setting off, to make sure that all shell commands have {{variable}} names visible instead of their values.
     */
    resetCommandPaletteNames() {
        let shell_commands = this.getShellCommands();
        for (let shell_command_id in shell_commands) {
            let shell_command_configuration = shell_commands[shell_command_id];
            this.obsidian_commands[shell_command_id].name = this.generateObsidianCommandName(shell_command_configuration);
        }
    }
    generateObsidianCommandId(shell_command_id) {
        return "shell-command-" + shell_command_id;
    }
    generateObsidianCommandName(shell_command_configuration) {
        let prefix = "Execute: ";
        if (shell_command_configuration.alias) {
            // If an alias is set for the command, Obsidian's command palette should display the alias text instead of the actual command.
            return prefix + shell_command_configuration.alias;
        }
        return prefix + shell_command_configuration.shell_command;
    }
    /**
     *
     * @param shell_command The actual shell command that will be executed.
     * @param shell_command_configuration Used for reading other properties. shell_command_configuration.shell_command won't be used!
     */
    confirmAndExecuteShellCommand(shell_command, shell_command_configuration) {
        // Check if the command needs confirmation before execution
        if (shell_command_configuration.confirm_execution) {
            // Yes, a confirmation is needed.
            // Open a confirmation modal.
            new ConfirmExecutionModal(this, shell_command, shell_command_configuration)
                .open();
            return; // Do not execute now. The modal will call executeShellCommand() later if needed.
        }
        else {
            // No need to confirm.
            // Execute.
            this.executeShellCommand(shell_command, shell_command_configuration);
        }
    }
    /**
     * Does not ask for confirmation before execution. This should only be called if: a) a confirmation is already asked from a user, or b) this command is defined not to need a confirmation.
     * Use confirmAndExecuteShellCommand() instead to have a confirmation asked before the execution.
     *
     * @param shell_command The actual shell command that will be executed.
     * @param shell_command_configuration Used for reading other properties. shell_command_configuration.shell_command won't be used!
     */
    executeShellCommand(shell_command, shell_command_configuration) {
        let working_directory = this.getWorkingDirectory();
        // Check that the shell command is not empty
        shell_command = shell_command.trim();
        if (!shell_command.length) {
            // It is empty
            console.log("The shell command is empty. :(");
            this.newError("The shell command is empty :(");
            return;
        }
        // Check that the working directory exists and is a folder
        if (!fs__namespace.existsSync(working_directory)) {
            // Working directory does not exist
            // Prevent execution
            console.log("Working directory does not exist: " + working_directory);
            this.newError("Working directory does not exist: " + working_directory);
        }
        else if (!fs__namespace.lstatSync(working_directory).isDirectory()) {
            // Working directory is not a directory.
            // Prevent execution
            console.log("Working directory exists but is not a folder: " + working_directory);
            this.newError("Working directory exists but is not a folder: " + working_directory);
        }
        else {
            // Working directory is OK
            // Execute the shell command
            console.log("Executing command " + shell_command + " in " + working_directory + "...");
            child_process.exec(shell_command, {
                "cwd": working_directory
            }, (error, stdout, stderr) => {
                if (null !== error) {
                    // Some error occurred
                    console.log("Command executed and failed. Error number: " + error.code + ". Message: " + error.message);
                    // Check if this error should be displayed to the user or not
                    if (shell_command_configuration.ignore_error_codes.contains(error.code)) {
                        // The user has ignored this error.
                        console.log("User has ignored this error, so won't display it.");
                        // Handle only stdout output stream
                        handleShellCommandOutput(this, shell_command_configuration, stdout, "", null);
                    }
                    else {
                        // Show the error.
                        console.log("Will display the error to user.");
                        // Check that stderr actually contains an error message
                        if (!stderr.length) {
                            // Stderr is empty, so the error message is probably given by Node.js's child_process.
                            // Direct error.message to the stderr variable, so that the user can see error.message when stderr is unavailable.
                            stderr = error.message;
                        }
                        // Handle both stdout and stderr output streams
                        handleShellCommandOutput(this, shell_command_configuration, stdout, stderr, error.code);
                    }
                }
                else {
                    // No errors
                    console.log("Command executed without errors.");
                    // Handle output
                    handleShellCommandOutput(this, shell_command_configuration, stdout, stderr, 0); // Use zero as an error code instead of null (0 means no error). If stderr happens to contain something, exit code 0 gets displayed in an error balloon (if that is selected as a driver for stderr).
                }
            });
        }
    }
    getWorkingDirectory() {
        // Returns either a user defined working directory, or an automatically detected one.
        let working_directory = this.settings.working_directory;
        if (working_directory.length == 0) {
            // No working directory specified, so use the vault directory.
            return getVaultAbsolutePath(this.app);
        }
        else if (!path__namespace.isAbsolute(working_directory)) {
            // The working directory is relative.
            // Help to make it refer to the vault's directory. Without this, the relative path would refer to Obsidian's installation directory (at least on Windows).
            return path__namespace.join(getVaultAbsolutePath(this.app), working_directory);
        }
        return working_directory;
    }
    onunload() {
        console.log('unloading plugin');
    }
    loadSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
        });
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveData(this.settings);
        });
    }
    /**
     * @return string Returns "0" if there are no shell commands yet, otherwise returns the max ID + 1, as a string.
     */
    generateNewShellCommandID() {
        let existing_ids = Object.getOwnPropertyNames(this.getShellCommands());
        let new_id = 0;
        for (let i in existing_ids) {
            let existing_id = parseInt(existing_ids[i]);
            if (existing_id >= new_id) {
                new_id = existing_id + 1;
            }
        }
        return String(new_id);
    }
    getPluginId() {
        return this.manifest.id;
    }
    getPluginName() {
        return this.manifest.name;
    }
    newError(message) {
        new obsidian.Notice(message, this.settings.error_message_duration * 1000); // * 1000 = convert seconds to milliseconds.
    }
    newErrors(messages) {
        messages.forEach((message) => {
            this.newError(message);
        });
    }
    newNotification(message) {
        new obsidian.Notice(message, this.settings.notification_message_duration * 1000); // * 1000 = convert seconds to milliseconds.
    }
}

module.exports = ShellCommandsPlugin;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXMiOlsibm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsInNyYy9Db21tb24udHMiLCJzcmMvdmFyaWFibGVzL1NoZWxsQ29tbWFuZFZhcmlhYmxlSW5zdHJ1Y3Rpb25zLnRzIiwic3JjL3ZhcmlhYmxlcy9TaGVsbENvbW1hbmRWYXJpYWJsZS50cyIsInNyYy92YXJpYWJsZXMvU2hlbGxDb21tYW5kVmFyaWFibGVfRm9sZGVyTmFtZS50cyIsInNyYy92YXJpYWJsZXMvU2hlbGxDb21tYW5kVmFyaWFibGVfU2VsZWN0aW9uLnRzIiwic3JjL3ZhcmlhYmxlcy9TaGVsbENvbW1hbmRWYXJpYWJsZV9GaWxlUGF0aC50cyIsInNyYy92YXJpYWJsZXMvU2hlbGxDb21tYW5kVmFyaWFibGVfQ2xpcGJvYXJkLnRzIiwic3JjL3ZhcmlhYmxlcy9TaGVsbENvbW1hbmRWYXJpYWJsZV9EYXRlLnRzIiwic3JjL3ZhcmlhYmxlcy9TaGVsbENvbW1hbmRWYXJpYWJsZV9WYXVsdFBhdGgudHMiLCJzcmMvdmFyaWFibGVzL1NoZWxsQ29tbWFuZFZhcmlhYmxlX0ZpbGVOYW1lLnRzIiwic3JjL3ZhcmlhYmxlcy9TaGVsbENvbW1hbmRWYXJpYWJsZV9Gb2xkZXJQYXRoLnRzIiwic3JjL3ZhcmlhYmxlcy9TaGVsbENvbW1hbmRWYXJpYWJsZV9UYWdzLnRzIiwic3JjL3ZhcmlhYmxlcy9TaGVsbENvbW1hbmRWYXJpYWJsZV9UaXRsZS50cyIsInNyYy92YXJpYWJsZXMvU2hlbGxDb21tYW5kVmFyaWFibGVfV29ya3NwYWNlLnRzIiwic3JjL3ZhcmlhYmxlcy9wYXJzZVNoZWxsQ29tbWFuZFZhcmlhYmxlcy50cyIsInNyYy9zZXR0aW5ncy9TaGVsbENvbW1hbmRDb25maWd1cmF0aW9uLnRzIiwic3JjL01pZ3JhdGlvbnMudHMiLCJzcmMvc2V0dGluZ3MvU2hlbGxDb21tYW5kc1BsdWdpblNldHRpbmdzLnRzIiwic3JjL291dHB1dF9jaGFubmVscy9PdXRwdXRDaGFubmVsRHJpdmVyLnRzIiwic3JjL291dHB1dF9jaGFubmVscy9PdXRwdXRDaGFubmVsRHJpdmVyX05vdGlmaWNhdGlvbi50cyIsInNyYy9vdXRwdXRfY2hhbm5lbHMvT3V0cHV0Q2hhbm5lbERyaXZlcl9DdXJyZW50RmlsZS50cyIsInNyYy9vdXRwdXRfY2hhbm5lbHMvT3V0cHV0Q2hhbm5lbERyaXZlcl9DdXJyZW50RmlsZUNhcmV0LnRzIiwic3JjL291dHB1dF9jaGFubmVscy9PdXRwdXRDaGFubmVsRHJpdmVyX0N1cnJlbnRGaWxlVG9wLnRzIiwic3JjL291dHB1dF9jaGFubmVscy9PdXRwdXRDaGFubmVsRHJpdmVyX1N0YXR1c0Jhci50cyIsInNyYy9vdXRwdXRfY2hhbm5lbHMvT3V0cHV0Q2hhbm5lbERyaXZlcl9DdXJyZW50RmlsZUJvdHRvbS50cyIsInNyYy9vdXRwdXRfY2hhbm5lbHMvT3V0cHV0Q2hhbm5lbERyaXZlcl9DbGlwYm9hcmQudHMiLCJzcmMvb3V0cHV0X2NoYW5uZWxzL091dHB1dENoYW5uZWxEcml2ZXJGdW5jdGlvbnMudHMiLCJzcmMvc2V0dGluZ3MvU2hlbGxDb21tYW5kRXh0cmFPcHRpb25zTW9kYWwudHMiLCJzcmMvc2V0dGluZ3MvU2hlbGxDb21tYW5kRGVsZXRlTW9kYWwudHMiLCJzcmMvSG90a2V5cy50cyIsInNyYy9zZXR0aW5ncy9TaGVsbENvbW1hbmRzU2V0dGluZ3NUYWIudHMiLCJzcmMvQ29uZmlybUV4ZWN1dGlvbk1vZGFsLnRzIiwic3JjL21haW4udHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcclxufVxyXG4iLCJpbXBvcnQge0FwcCwgRWRpdG9yLCBGaWxlU3lzdGVtQWRhcHRlciwgTWFya2Rvd25WaWV3LCBub3JtYWxpemVQYXRofSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRWYXVsdEFic29sdXRlUGF0aChhcHA6IEFwcCkge1xyXG4gICAgLy8gT3JpZ2luYWwgY29kZSB3YXMgY29waWVkIDIwMjEtMDgtMjIgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcGhpYnIwL29ic2lkaWFuLW9wZW4td2l0aC9ibG9iLzg0ZjBlMjViYThlODM1NWZmODNiMjJmNDA1MGFkZGU0Y2M2NzYzZWEvbWFpbi50cyNMNjYtTDY3XHJcbiAgICAvLyBCdXQgdGhlIGNvZGUgaGFzIGJlZW4gcmV3cml0dGVuIDIwMjEtMDgtMjcgYXMgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9vYnNpZGlhbm1kL29ic2lkaWFuLXJlbGVhc2VzL3B1bGwvNDMzI2lzc3VlY29tbWVudC05MDYwODcwOTVcclxuICAgIGxldCBhZGFwdGVyID0gYXBwLnZhdWx0LmFkYXB0ZXI7XHJcbiAgICBpZiAoYWRhcHRlciBpbnN0YW5jZW9mIEZpbGVTeXN0ZW1BZGFwdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXIuZ2V0QmFzZVBhdGgoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogRm9yIHNvbWUgcmVhc29uIHRoZXJlIGlzIG5vIFBsYXRmb3JtLmlzV2luZG93cyAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNXaW5kb3dzKCkge1xyXG4gICAgcmV0dXJuIHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFZpZXcoYXBwOiBBcHApIHtcclxuICAgIGxldCB2aWV3ID0gYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XHJcbiAgICBpZiAoIXZpZXcpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcImdldFZpZXcoKTogQ291bGQgbm90IGdldCBhIHZpZXcuIFdpbGwgcmV0dXJuIG51bGwuXCIpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZpZXc7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRFZGl0b3IoYXBwOiBBcHApOiBFZGl0b3Ige1xyXG5cclxuICAgIGxldCB2aWV3ID0gZ2V0VmlldyhhcHApO1xyXG4gICAgaWYgKG51bGwgPT09IHZpZXcpIHtcclxuICAgICAgICAvLyBDb3VsZCBub3QgZ2V0IGEgdmlldy5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFbnN1cmUgdGhhdCB2aWV3LmVkaXRvciBleGlzdHMhIEl0IGV4aXN0cyBhdCBsZWFzdCBpZiB0aGlzIGlzIGEgTWFya0Rvd25WaWV3LlxyXG4gICAgaWYgKFwiZWRpdG9yXCIgaW4gdmlldykge1xyXG4gICAgICAgIC8vIEdvb2QsIGl0IGV4aXN0cy5cclxuICAgICAgICAvLyBAdHMtaWdub3JlIFdlIGFscmVhZHkga25vdyB0aGF0IHZpZXcuZWRpdG9yIGV4aXN0cy5cclxuICAgICAgICByZXR1cm4gdmlldy5lZGl0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGlkIG5vdCBmaW5kIGFuIGVkaXRvci5cclxuICAgIGNvbnNvbGUubG9nKFwiZ2V0RWRpdG9yKCk6ICd2aWV3JyBkb2VzIG5vdCBoYXZlIGEgcHJvcGVydHkgbmFtZWQgJ2VkaXRvcicuIFdpbGwgcmV0dXJuIG51bGwuXCIpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbG9uZU9iamVjdChvYmplY3Q6IE9iamVjdCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9iamVjdCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTYW1lIGFzIG5vcm1hbGl6ZVBhdGgoKSwgYnV0IGZpeGVzIHRoZXNlIGdsaXRjaGVzOlxyXG4gKiAtIExlYWRpbmcgZm9yd2FyZCBzbGFzaGVzIC8gYmFja3dhcmQgc2xhc2hlcyBzaG91bGQgbm90IGJlIHJlbW92ZWQuXHJcbiAqIC0gXFwgc2hvdWxkIG5vdCBiZSBjb252ZXJ0ZWQgdG8gLyBpZiBwbGF0Zm9ybSBpcyBXaW5kb3dzLiBJbiBvdGhlciB3b3JkcywgLyBzaG91bGQgYmUgY29udmVydGVkIHRvIFxcIGlmIHBsYXRmb3JtIGlzIFdpbmRvd3MuXHJcbiAqXHJcbiAqIFRPRE86IEkndmUgb3BlbmVkIGEgZGlzY3Vzc2lvbiBhYm91dCB0aGlzIG9uIE9ic2lkaWFuJ3MgZm9ydW1zLiBJZiBhbnl0aGluZyBuZXcgY29tZXMgdXAgaW4gdGhlIGRpc2N1c3Npb24sIG1ha2UgY2hhbmdlcyBhY2NvcmRpbmdseS4gaHR0cHM6Ly9mb3J1bS5vYnNpZGlhbi5tZC90L25vcm1hbGl6ZXBhdGgtcmVtb3Zlcy1hLWxlYWRpbmcvMjQ3MTNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVQYXRoMihwYXRoOiBzdHJpbmcpIHtcclxuICAgIC8vIDEuIFByZXBhcmF0aW9uc1xyXG4gICAgcGF0aCA9IHBhdGgudHJpbSgpO1xyXG4gICAgbGV0IGxlYWRpbmdfc2xhc2hlc19yZWdleHAgPSAvXlsvXFxcXF0qL2c7IC8vIEdldCBhcyBtYW55IC8gb3IgXFwgc2xhc2hlcyBhcyB0aGVyZSBhcmUgaW4gdGhlIHZlcnkgYmVnaW5uaW5nIG9mIHBhdGguIENhbiBhbHNvIGJlIFwiXCIgKGFuIGVtcHR5IHN0cmluZykuXHJcbiAgICBsZXQgbGVhZGluZ19zbGFzaGVzID0gbGVhZGluZ19zbGFzaGVzX3JlZ2V4cC5leGVjKHBhdGgpWzBdO1xyXG5cclxuICAgIC8vIDIuIFJ1biB0aGUgb3JpZ2luYWwgbm9ybWFsaXplUGF0aCgpXHJcbiAgICBwYXRoID0gbm9ybWFsaXplUGF0aChwYXRoKTtcclxuXHJcbiAgICAvLyAzLiBGaXhlc1xyXG4gICAgLy8gQ2hlY2sgdGhhdCBjb3JyZWN0IHNsYXNoZXMgYXJlIHVzZWQuXHJcbiAgICBpZiAoaXNXaW5kb3dzKCkpIHtcclxuICAgICAgICAvLyBUaGUgcGxhdGZvcm0gaXMgV2luZG93cy5cclxuICAgICAgICAvLyBDb252ZXJ0IC8gdG8gXFxcclxuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC8vZywgXCJcXFxcXCIpOyAvLyBOZWVkIHRvIHVzZSBhIHJlZ2V4cCBpbnN0ZWFkIG9mIGEgbm9ybWFsIFwiL1wiIC0+IFwiXFxcXFwiIHJlcGxhY2UgYmVjYXVzZSB0aGUgbm9ybWFsIHJlcGxhY2Ugd291bGQgb25seSByZXBsYWNlIGZpcnN0IG9jY3VycmVuY2Ugb2YgLy5cclxuICAgICAgICBsZWFkaW5nX3NsYXNoZXMgPSBsZWFkaW5nX3NsYXNoZXMucmVwbGFjZSgvXFwvL2csIFwiXFxcXFwiKTsgLy8gU2FtZSBoZXJlLlxyXG4gICAgfVxyXG4gICAgLy8gTm93IGVuc3VyZSB0aGF0IHBhdGggc3RpbGwgY29udGFpbnMgbGVhZGluZyBzbGFzaGVzIChpZiB0aGVyZSB3ZXJlIGFueSBiZWZvcmUgY2FsbGluZyBub3JtYWxpemVQYXRoKCkpLlxyXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgcGF0aCBzaG91bGQgaGF2ZSBhIHNpbWlsYXIgc2V0IG9mIGxlYWRpbmcgc2xhc2hlcyBhdCB0aGUgYmVnaW5uaW5nLiBJdCBjYW4gYmUgYXQgbGVhc3QgXCIvXCIgKG9uIGxpbnV4L01hYyksIG9yIFwiXFxcXFwiIChvbiBXaW5kb3dzIHdoZW4gaXQncyBhIG5ldHdvcmsgcGF0aCksIGluIHRoZW9yeSBldmVuIFwiLy8vXCIgb3IgXCJcXFxcXFxcXFxcXCIgd2hhdGV2ZXIuXHJcbiAgICAvLyBub3JtYWxpemVQYXRoKCkgc2VlbXMgdG8gcmVtb3ZlIGxlYWRpbmcgc2xhc2hlcyAoYW5kIHRoZXkgYXJlIG5lZWRlZCB0byBiZSByZS1hZGRlZCksIGJ1dCBpdCdzIG5lZWRlZCB0byBjaGVjayBmaXJzdCwgb3RoZXJ3aXNlIHRoZSBwYXRoIHdvdWxkIGhhdmUgZG91YmxlIGxlYWRpbmcgc2xhc2hlcyBpZiBub3JtYWxpemVQYXRoKCkgZ2V0cyBmaXhlZCBpbiB0aGUgZnV0dXJlLlxyXG4gICAgaWYgKGxlYWRpbmdfc2xhc2hlcy5sZW5ndGggJiYgcGF0aC5zbGljZSgwLCBsZWFkaW5nX3NsYXNoZXMubGVuZ3RoKSAhPT0gbGVhZGluZ19zbGFzaGVzKSB7XHJcbiAgICAgICAgLy8gVGhlIHBhdGggZG9lcyBub3QgY29udGFpbiB0aGUgcmVxdWlyZWQgc2V0IG9mIGxlYWRpbmcgc2xhc2hlcywgc28gYWRkIHRoZW0uXHJcbiAgICAgICAgcGF0aCA9IGxlYWRpbmdfc2xhc2hlcyArIHBhdGg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gNC4gRG9uZVxyXG4gICAgcmV0dXJuIHBhdGg7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBqb2luT2JqZWN0UHJvcGVydGllcyhvYmplY3Q6IHt9LCBnbHVlOiBzdHJpbmcpIHtcclxuICAgIGxldCByZXN1bHQgPSBcIlwiO1xyXG4gICAgZm9yIChsZXQgcHJvcGVydHlfbmFtZSBpbiBvYmplY3QpIHtcclxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gZ2x1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIHJlc3VsdCArPSBvYmplY3RbcHJvcGVydHlfbmFtZV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBhbGwgZHVwbGljYXRlcyBmcm9tIGFuIGFycmF5LlxyXG4gKlxyXG4gKiBJZGVhIGlzIGNvcGllZCAyMDIxLTEwLTA2IGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMzMTIxODgwLzI3NTQwMjZcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1bmlxdWVBcnJheShhcnJheTogYW55W10pIHtcclxuICAgIHJldHVybiBbLi4ubmV3IFNldChhcnJheSldO1xyXG59IiwiaW50ZXJmYWNlIFNoZWxsQ29tbWFuZFZhcmlhYmxlSW5zdHJ1Y3Rpb24ge1xyXG4gICAgdmFyaWFibGVfbmFtZTogc3RyaW5nLFxyXG4gICAgaW5zdHJ1Y3Rpb25zOiBzdHJpbmcsXHJcbn1cclxuXHJcbmxldCBzaGVsbF9jb21tYW5kX3ZhcmlhYmxlX2luc3RydWN0aW9uczogU2hlbGxDb21tYW5kVmFyaWFibGVJbnN0cnVjdGlvbltdID0gW107XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2hlbGxDb21tYW5kVmFyaWFibGVJbnN0cnVjdGlvbnMoKSB7XHJcbiAgICBzb3J0X3NoZWxsX2NvbW1hbmRfdmFyaWFibGVfaW5zdHJ1Y3Rpb25zKCk7IC8vIE1ha2Ugc3VyZSB0aGUgdmFyaWFibGVzIGFyZSBpbiBjb3JyZWN0IG9yZGVyLlxyXG4gICAgcmV0dXJuIHNoZWxsX2NvbW1hbmRfdmFyaWFibGVfaW5zdHJ1Y3Rpb25zO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYWRkU2hlbGxDb21tYW5kVmFyaWFibGVJbnN0cnVjdGlvbnModmFyaWFibGVfbmFtZTogc3RyaW5nLCBpbnN0cnVjdGlvbnM6IHN0cmluZykge1xyXG4gICAgc2hlbGxfY29tbWFuZF92YXJpYWJsZV9pbnN0cnVjdGlvbnMucHVzaCh7XHJcbiAgICAgICAgdmFyaWFibGVfbmFtZTogdmFyaWFibGVfbmFtZSxcclxuICAgICAgICBpbnN0cnVjdGlvbnM6IGluc3RydWN0aW9ucyxcclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogU29ydHMgc2hlbGxfY29tbWFuZF92YXJpYWJsZV9pbnN0cnVjdGlvbnMgYWxwaGFiZXRpY2FsbHkgYmFzZWQgb24gdmFyaWFibGVfbmFtZS5cclxuICovXHJcbmZ1bmN0aW9uIHNvcnRfc2hlbGxfY29tbWFuZF92YXJpYWJsZV9pbnN0cnVjdGlvbnMoKSB7XHJcbiAgICBzaGVsbF9jb21tYW5kX3ZhcmlhYmxlX2luc3RydWN0aW9ucy5zb3J0KChhOiBTaGVsbENvbW1hbmRWYXJpYWJsZUluc3RydWN0aW9uLCBiOiBTaGVsbENvbW1hbmRWYXJpYWJsZUluc3RydWN0aW9uKSA9PiB7XHJcbiAgICAgICAgaWYgKGEudmFyaWFibGVfbmFtZSA8IGIudmFyaWFibGVfbmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChhLnZhcmlhYmxlX25hbWUgPiBiLnZhcmlhYmxlX25hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfSk7XHJcbn0iLCJpbXBvcnQge0FwcH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCBTaGVsbENvbW1hbmRzUGx1Z2luIGZyb20gXCIuLi9tYWluXCI7XHJcblxyXG5pbnRlcmZhY2UgSUFyZ3VtZW50cyB7XHJcbiAgICBba2V5OiBzdHJpbmddOiBhbnk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBrZXkgPSBzdHJpbmcsIHBhcmFtZXRlciBuYW1lXHJcbiAqIHZhbHVlID0gYm9vbGVhbiwgaXMgdGhlIHBhcmFtZXRlciBtYW5kYXRvcnkgb3Igbm90P1xyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJUGFyYW1ldGVycyB7XHJcbiAgICBba2V5OiBzdHJpbmddOiB7XHJcbiAgICAgICAgLyoqIFdoYXQgZGF0YSB0eXBlIGlzIGFsbG93ZWQuIChOZXcgdHlwZXMgY2FuIGJlIGFkZGVkIGxhdGVyKS4gU2hvdWxkIGJlIG9taXR0ZWQsIGlmICdvcHRpb25zJyBpcyB1c2VkLiAqL1xyXG4gICAgICAgIHR5cGU/OiBcInN0cmluZ1wiIHwgXCJpbnRlZ2VyXCI7XHJcbiAgICAgICAgLyoqIFRoaXMgY2FuIGRlZmluZSBzdGF0aWMgdmFsdWVzIGZvciB0aGlzIHBhcmFtZXRlci4gU2hvdWxkIGJlIG9taXR0ZWQsIGlmICd0eXBlJyBpcyB1c2VkLiAqL1xyXG4gICAgICAgIG9wdGlvbnM/OiBzdHJpbmdbXTtcclxuICAgICAgICAvKiogSXMgdGhpcyBwYXJhbWV0ZXIgbWFuZGF0b3J5PyAqL1xyXG4gICAgICAgIHJlcXVpcmVkOiBib29sZWFuO1xyXG4gICAgfTtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGVsbENvbW1hbmRWYXJpYWJsZSB7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBhcmFtZXRlcl9zZXBhcmF0b3IgPSBcIjpcIjtcclxuICAgIHJlYWRvbmx5IHBsdWdpbjogU2hlbGxDb21tYW5kc1BsdWdpbjtcclxuICAgIHJlYWRvbmx5IGFwcDogQXBwO1xyXG4gICAgcHJpdmF0ZSBlcnJvcl9tZXNzYWdlczogc3RyaW5nW10gPSBbXTtcclxuICAgIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgZGVmaW5pdGlvbiBmb3Igd2hhdCBwYXJhbWV0ZXJzIHRoaXMgdmFyaWFibGVzIHRha2VzLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgcGFyYW1ldGVyczogSVBhcmFtZXRlcnMgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgY29udGFpbnMgYWN0dWFsIHZhbHVlcyBmb3IgcGFyYW1ldGVycy5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFyZ3VtZW50czogSUFyZ3VtZW50cyA9IHt9O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHBsdWdpbjogU2hlbGxDb21tYW5kc1BsdWdpbikge1xyXG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luXHJcbiAgICAgICAgdGhpcy5hcHAgPSBwbHVnaW4uYXBwO1xyXG4gICAgfVxyXG5cclxuICAgIGFic3RyYWN0IGdldFZhbHVlKCk6IHN0cmluZ3xudWxsO1xyXG5cclxuICAgIGdldFBhdHRlcm4oKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JfcHJlZml4ID0gdGhpcy5uYW1lICsgXCIuZ2V0UGF0dGVybigpOiBcIjtcclxuICAgICAgICBsZXQgcGF0dGVybiA9ICdcXHtcXHsnICsgdGhpcy5uYW1lO1xyXG4gICAgICAgIGZvciAobGV0IHBhcmFtZXRlcl9uYW1lIGluIHRoaXMucGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXIgPSB0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVyX25hbWVdO1xyXG4gICAgICAgICAgICBsZXQgcGFyYW1ldGVyX3R5cGVfcGF0dGVybjogc3RyaW5nID0gdGhpcy5wYXJhbWV0ZXJfc2VwYXJhdG9yOyAgLy8gSGVyZSB0aGlzLnBhcmFtZXRlcl9zZXBhcmF0b3IgKD0gOiApIGlzIGluY2x1ZGVkIGluIHRoZSBwYXJhbWV0ZXIgdmFsdWUganVzdCBzbyB0aGF0IGl0J3Mgbm90IG5lZWRlZCB0byBkbyBuZXN0ZWQgcGFyZW50aGVzaXMgdG8gYWNjb21wbGlzaCBwb3NzaWJsZSBvcHRpb25hbGl0eTogKDooKSk/LiBwYXJzZVNoZWxsQ29tbWFuZFZhcmlhYmxlcygpIHdpbGwgcmVtb3ZlIHRoZSBsZWFkaW5nIDogLlxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgc2hvdWxkIHdlIHVzZSBwYXJhbWV0ZXIub3B0aW9ucyBvciBwYXJhbWV0ZXIudHlwZS5cclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkID09PSBwYXJhbWV0ZXIub3B0aW9ucyAmJlxyXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkID09PSBwYXJhbWV0ZXIudHlwZVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIC8vIE5laXRoZXIgaXMgZGVmaW5lZCA6KFxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoZXJyb3JfcHJlZml4ICsgXCJQYXJhbWV0ZXIgJ1wiICsgcGFyYW1ldGVyX25hbWUgKyBcIicgc2hvdWxkIGRlZmluZSBlaXRoZXIgJ3R5cGUnIG9yICdvcHRpb25zJywgbmVpdGhlciBpcyBkZWZpbmVkIVwiKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCAhPT0gcGFyYW1ldGVyLm9wdGlvbnMgJiZcclxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCAhPT0gcGFyYW1ldGVyLnR5cGVcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBCb3RoIGFyZSBkZWZpbmVkIDooXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihlcnJvcl9wcmVmaXggKyBcIlBhcmFtZXRlciAnXCIgKyBwYXJhbWV0ZXJfbmFtZSArIFwiJyBzaG91bGQgZGVmaW5lIGVpdGhlciAndHlwZScgb3IgJ29wdGlvbnMnLCBub3QgYm90aCFcIik7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodW5kZWZpbmVkICE9PSBwYXJhbWV0ZXIub3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgLy8gVXNlIHBhcmFtZXRlci5vcHRpb25zXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJfdHlwZV9wYXR0ZXJuICs9IHBhcmFtZXRlci5vcHRpb25zLmpvaW4oXCJ8XCIgKyB0aGlzLnBhcmFtZXRlcl9zZXBhcmF0b3IpOyAvLyBFLmcuIFwiYWJzb2x1dGV8OnJlbGF0aXZlXCIgZm9yIHt7ZmlsZV9wYXRoOm1vZGV9fSB2YXJpYWJsZSdzICdtb2RlJyBwYXJhbWV0ZXIuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVc2UgcGFyYW1ldGVyLnR5cGVcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAocGFyYW1ldGVyLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcl90eXBlX3BhdHRlcm4gKz0gXCIuKj9cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImludGVnZXJcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyX3R5cGVfcGF0dGVybiArPSBcIlxcXFxkK1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihlcnJvcl9wcmVmaXggKyBcIlBhcmFtZXRlciAnXCIgKyBwYXJhbWV0ZXJfbmFtZSArIFwiJyBoYXMgYW4gdW5yZWNvZ25pc2VkIHR5cGU6IFwiICsgcGFyYW1ldGVyLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHN1YnBhdHRlcm4gdG8gJ3BhdHRlcm4nLlxyXG4gICAgICAgICAgICBwYXR0ZXJuICs9IFwiKFwiICsgcGFyYW1ldGVyX3R5cGVfcGF0dGVybiArIFwiKVwiO1xyXG4gICAgICAgICAgICBpZiAoIXBhcmFtZXRlci5yZXF1aXJlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gTWFrZSB0aGUgcGFyYW1ldGVyIG9wdGlvbmFsLlxyXG4gICAgICAgICAgICAgICAgcGF0dGVybiArPSBcIj9cIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgcGF0dGVybiArPSAnXFx9XFx9JztcclxuICAgICAgICByZXR1cm4gcGF0dGVybjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UGFyYW1ldGVyTmFtZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMucGFyYW1ldGVycyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVyX25hbWVcclxuICAgICAqIEBwYXJhbSBhcmd1bWVudCBBdCB0aGlzIHBvaW50ICdhcmd1bWVudCcgaXMgYWx3YXlzIGEgc3RyaW5nLCBidXQgdGhpcyBtZXRob2QgbWF5IGNvbnZlcnQgaXQgdG8gYW5vdGhlciBkYXRhIHR5cGUsIGRlcGVuZGluZyBvbiB0aGUgcGFyYW1ldGVyJ3MgZGF0YSB0eXBlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0QXJndW1lbnQocGFyYW1ldGVyX25hbWU6IHN0cmluZywgYXJndW1lbnQ6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcl90eXBlID0gdGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlcl9uYW1lXS50eXBlID8/IFwic3RyaW5nXCI7IC8vIElmIHRoZSB2YXJpYWJsZSB1c2VzIFwib3B0aW9uc1wiIGluc3RlYWQgb2YgXCJ0eXBlXCIsIHRoZW4gdGhlIHR5cGUgaXMgYWx3YXlzIFwic3RyaW5nXCIuXHJcbiAgICAgICAgc3dpdGNoIChwYXJhbWV0ZXJfdHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFyZ3VtZW50c1twYXJhbWV0ZXJfbmFtZV0gPSBhcmd1bWVudDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiaW50ZWdlclwiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5hcmd1bWVudHNbcGFyYW1ldGVyX25hbWVdID0gcGFyc2VJbnQoYXJndW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm90ZSB0aGF0IGVycm9yIG1lc3NhZ2VzIGNhbiBvbmx5IGV4aXN0IGFmdGVyIGdldFZhbHVlKCkgaXMgY2FsbGVkIVxyXG4gICAgICovXHJcbiAgICBnZXRFcnJvck1lc3NhZ2VzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yX21lc3NhZ2VzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBuZXdFcnJvck1lc3NhZ2UobWVzc2FnZTogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IHByZWZpeCA9IFwie3tcIiArIHRoaXMubmFtZSArIFwifX06IFwiO1xyXG4gICAgICAgIHRoaXMuZXJyb3JfbWVzc2FnZXMucHVzaChwcmVmaXggKyBtZXNzYWdlKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQge2FkZFNoZWxsQ29tbWFuZFZhcmlhYmxlSW5zdHJ1Y3Rpb25zfSBmcm9tIFwiLi9TaGVsbENvbW1hbmRWYXJpYWJsZUluc3RydWN0aW9uc1wiO1xyXG5pbXBvcnQge1NoZWxsQ29tbWFuZFZhcmlhYmxlfSBmcm9tIFwiLi9TaGVsbENvbW1hbmRWYXJpYWJsZVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFNoZWxsQ29tbWFuZFZhcmlhYmxlX0ZvbGRlck5hbWUgZXh0ZW5kcyBTaGVsbENvbW1hbmRWYXJpYWJsZXtcclxuICAgIG5hbWUgPSBcImZvbGRlcl9uYW1lXCI7XHJcbiAgICBnZXRWYWx1ZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIGxldCBmaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcclxuICAgICAgICBpZiAoIWZpbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5uZXdFcnJvck1lc3NhZ2UoXCJObyBmaWxlIGlzIGFjdGl2ZSBhdCB0aGUgbW9tZW50LiBPcGVuIGEgZmlsZSBvciBjbGljayBhIHBhbmUgdGhhdCBoYXMgYSBmaWxlIG9wZW4uXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gbnVsbCBpbmRpY2F0ZXMgdGhhdCBnZXR0aW5nIGEgdmFsdWUgaGFzIGZhaWxlZCBhbmQgdGhlIGNvbW1hbmQgc2hvdWxkIG5vdCBiZSBleGVjdXRlZC5cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFmaWxlLnBhcmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLm5ld0Vycm9yTWVzc2FnZShcIlRoZSBjdXJyZW50IGZpbGUgZG9lcyBub3QgaGF2ZSBhIHBhcmVudCBmb3Igc29tZSBzdHJhbmdlIHJlYXNvbi5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBudWxsIGluZGljYXRlcyB0aGF0IGdldHRpbmcgYSB2YWx1ZSBoYXMgZmFpbGVkIGFuZCB0aGUgY29tbWFuZCBzaG91bGQgbm90IGJlIGV4ZWN1dGVkLlxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmlsZS5wYXJlbnQubmFtZTtcclxuICAgIH1cclxufVxyXG5hZGRTaGVsbENvbW1hbmRWYXJpYWJsZUluc3RydWN0aW9ucyhcclxuICAgIFwie3tmb2xkZXJfbmFtZX19XCIsXHJcbiAgICBcIkdpdmVzIHRoZSBjdXJyZW50IGZpbGUncyBwYXJlbnQgZm9sZGVyIG5hbWUuIE5vIGFuY2VzdG9yIGZvbGRlcnMgYXJlIGluY2x1ZGVkLlwiLFxyXG4pOyIsImltcG9ydCB7Z2V0RWRpdG9yLCBnZXRWaWV3fSBmcm9tIFwiLi4vQ29tbW9uXCI7XHJcbmltcG9ydCB7YWRkU2hlbGxDb21tYW5kVmFyaWFibGVJbnN0cnVjdGlvbnN9IGZyb20gXCIuL1NoZWxsQ29tbWFuZFZhcmlhYmxlSW5zdHJ1Y3Rpb25zXCI7XHJcbmltcG9ydCB7U2hlbGxDb21tYW5kVmFyaWFibGV9IGZyb20gXCIuL1NoZWxsQ29tbWFuZFZhcmlhYmxlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgU2hlbGxDb21tYW5kVmFyaWFibGVfU2VsZWN0aW9uIGV4dGVuZHMgU2hlbGxDb21tYW5kVmFyaWFibGV7XHJcbiAgICBuYW1lID0gXCJzZWxlY3Rpb25cIjtcclxuICAgIGdldFZhbHVlKCk6IHN0cmluZyB7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRoYXQgd2UgYXJlIGFibGUgdG8gZ2V0IGEgdmlld1xyXG4gICAgICAgIGxldCB2aWV3ID0gZ2V0Vmlldyh0aGlzLmFwcCk7XHJcbiAgICAgICAgaWYgKG51bGwgPT09IHZpZXcpIHtcclxuICAgICAgICAgICAgLy8gTm9wZS5cclxuICAgICAgICAgICAgdGhpcy5uZXdFcnJvck1lc3NhZ2UoXCJDb3VsZCBub3QgZ2V0IGEgdmlldyBpbnN0YW5jZSEgUGxlYXNlIHJhaXNlIGFuIGlzc3VlIGluIEdpdEh1Yi5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSBhcmUgYWJsZSB0byBnZXQgYW4gZWRpdG9yXHJcbiAgICAgICAgbGV0IGVkaXRvciA9IGdldEVkaXRvcih0aGlzLmFwcCk7XHJcbiAgICAgICAgaWYgKG51bGwgPT09IGVkaXRvcikge1xyXG4gICAgICAgICAgICAvLyBOb3BlLlxyXG4gICAgICAgICAgICB0aGlzLm5ld0Vycm9yTWVzc2FnZShcIkNvdWxkIG5vdCBnZXQgYW4gZWRpdG9yIGluc3RhbmNlISBQbGVhc2UgcmFpc2UgYW4gaXNzdWUgaW4gR2l0SHViLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayB0aGUgdmlldyBtb2RlXHJcbiAgICAgICAgbGV0IHZpZXdfbW9kZSA9IHZpZXcuZ2V0TW9kZSgpOyAvLyBcInByZXZpZXdcIiBvciBcInNvdXJjZVwiIChjYW4gYWxzbyBiZSBcImxpdmVcIiBidXQgSSBkb24ndCBrbm93IHdoZW4gdGhhdCBoYXBwZW5zKVxyXG4gICAgICAgIHN3aXRjaCAodmlld19tb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwcmV2aWV3XCI6XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgbGVhZiBpcyBpbiBwcmV2aWV3IG1vZGUsIHdoaWNoIG1ha2VzIHRoaW5ncyBkaWZmaWN1bHQuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBjb3VsZCBzdGlsbCByZXR1cm4gdmlldy5lZGl0b3IsIGJ1dCBpdCBkb2VzIG5vdCB3b3JrIGF0IGxlYXN0IGZvciBnZXR0aW5nIHNlbGVjdGVkIHRleHQsIG1heWJlIGZvciBvdGhlciB0aGluZ3MsIGJ1dCBjdXJyZW50bHkgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgZm9yIGdldHRpbmcgc2VsZWN0ZWQgdGV4dC5cclxuICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgbW9tZW50LCBqdXN0IHJldHVybiBudWxsIHRvIGluZGljYXRlIHRoYXQgd2Ugd2VyZSBub3QgYWJsZSB0byBvZmZlciBhbiBlZGl0b3IgaW5zdGFuY2Ugd2hpY2ggY291bGQgd29yayByZWxpYWJseSBvbiB0ZXh0IHNlbGVjdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogTWFrZSBpdCBwb3NzaWJsZSB0byB1c2UgdGhpcyBmZWF0dXJlIGFsc28gaW4gcHJldmlldyBtb2RlLlxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTaGVsbENvbW1hbmRWYXJpYWJsZV9TZWxlY3Rpb246ICd2aWV3JyBpcyBpbiBwcmV2aWV3IG1vZGUsIGFuZCB0aGUgcG9vciBndXkgd2hvIHdyb3RlIHRoaXMgY29kZSwgZG9lcyBub3Qga25vdyBob3cgdG8gcmV0dXJuIGFuIGVkaXRvciBpbnN0YW5jZSB0aGF0IGNvdWxkIGJlIHVzZWQgZm9yIGdldHRpbmcgdGV4dCBzZWxlY3Rpb24uXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXdFcnJvck1lc3NhZ2UoXCJZb3UgbmVlZCB0byB0dXJuIGVkaXRpbmcgbW9kZSBvbiwgYXMgSSdtIG5vdCBhYmxlIHRvIGdldCBzZWxlY3RlZCB0ZXh0IHdoZW4gaW4gcHJldmlldyBtb2RlLiBCbGFtZSB0aGUgb25lIHdobyBkZXZlbG9wZWQgdGhpcyBwbHVnaW4hIFRoaXMgc2hvdWxkIGJlIGZpeGVkIGluIHRoZSBmdXR1cmUuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzb3VyY2VcIjpcclxuICAgICAgICAgICAgICAgIC8vIEdvb2QsIHRoZSBlZGl0b3IgaXMgaW4gXCJzb3VyY2VcIiBtb2RlLCBzbyBpdCdzIHBvc3NpYmxlIHRvIGdldCBhIHNlbGVjdGlvbi5cclxuICAgICAgICAgICAgICAgIGlmIChlZGl0b3Iuc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIEVycm9yKFwiU2hlbGxDb21tYW5kVmFyaWFibGVfU2VsZWN0aW9uOiBVbnJlY29nbmlzZWQgdmlldyBtb2RlOiBcIit2aWV3X21vZGUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmFkZFNoZWxsQ29tbWFuZFZhcmlhYmxlSW5zdHJ1Y3Rpb25zKFxyXG4gICAgXCJ7e3NlbGVjdGlvbn19XCIsXHJcbiAgICBcIkdpdmVzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dC4gQXRtIG9ubHkgd29ya3MgaW4gZWRpdGluZyBtb2RlLCBub3QgaW4gcHJldmlldyBtb2RlIVwiLFxyXG4pOyIsImltcG9ydCB7YWRkU2hlbGxDb21tYW5kVmFyaWFibGVJbnN0cnVjdGlvbnN9IGZyb20gXCIuL1NoZWxsQ29tbWFuZFZhcmlhYmxlSW5zdHJ1Y3Rpb25zXCI7XHJcbmltcG9ydCB7Z2V0VmF1bHRBYnNvbHV0ZVBhdGgsIG5vcm1hbGl6ZVBhdGgyfSBmcm9tIFwiLi4vQ29tbW9uXCI7XHJcbmltcG9ydCB7SVBhcmFtZXRlcnMsIFNoZWxsQ29tbWFuZFZhcmlhYmxlfSBmcm9tIFwiLi9TaGVsbENvbW1hbmRWYXJpYWJsZVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFNoZWxsQ29tbWFuZFZhcmlhYmxlX0ZpbGVQYXRoIGV4dGVuZHMgU2hlbGxDb21tYW5kVmFyaWFibGV7XHJcbiAgICBuYW1lID0gXCJmaWxlX3BhdGhcIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgcGFyYW1ldGVyczogSVBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgbW9kZToge1xyXG4gICAgICAgICAgICBvcHRpb25zOiBbXCJhYnNvbHV0ZVwiLCBcInJlbGF0aXZlXCJdLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgYXJndW1lbnRzOiB7XHJcbiAgICAgICAgbW9kZTogc3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFZhbHVlKCk6IHN0cmluZ3xudWxsIHtcclxuICAgICAgICBsZXQgYWN0aXZlX2ZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xyXG4gICAgICAgIGlmIChhY3RpdmVfZmlsZSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuYXJndW1lbnRzLm1vZGUudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImFic29sdXRlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVBhdGgyKGdldFZhdWx0QWJzb2x1dGVQYXRoKHRoaXMuYXBwKSArIFwiL1wiICsgYWN0aXZlX2ZpbGUucGF0aCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVsYXRpdmVcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplUGF0aDIoYWN0aXZlX2ZpbGUucGF0aCk7IC8vIE5vcm1hbGl6ZSB0byBnZXQgYSBjb3JyZWN0IHNsYXNoIGRlcGVuZGluZyBvbiBwbGF0Zm9ybS4gT24gV2luZG93cyBpdCBzaG91bGQgYmUgXFwgLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5uZXdFcnJvck1lc3NhZ2UoXCJObyBmaWxlIGlzIGFjdGl2ZSBhdCB0aGUgbW9tZW50LiBPcGVuIGEgZmlsZSBvciBjbGljayBhIHBhbmUgdGhhdCBoYXMgYSBmaWxlIG9wZW4uXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gbnVsbCBpbmRpY2F0ZXMgdGhhdCBnZXR0aW5nIGEgdmFsdWUgaGFzIGZhaWxlZCBhbmQgdGhlIGNvbW1hbmQgc2hvdWxkIG5vdCBiZSBleGVjdXRlZC5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuYWRkU2hlbGxDb21tYW5kVmFyaWFibGVJbnN0cnVjdGlvbnMoXHJcbiAgICBcInt7ZmlsZV9wYXRoOnJlbGF0aXZlfX0gb3Ige3tmaWxlX3BhdGg6YWJzb2x1dGV9fVwiLFxyXG4gICAgXCJHaXZlcyBwYXRoIHRvIHRoZSBjdXJyZW50IGZpbGUsIGVpdGhlciBhcyBhYnNvbHV0ZSBmcm9tIHRoZSByb290IG9mIHRoZSBmaWxlIHN5c3RlbSwgb3IgYXMgcmVsYXRpdmUgZnJvbSB0aGUgcm9vdCBvZiB0aGUgT2JzaWRpYW4gdmF1bHQuXCIsXHJcbik7IiwiaW1wb3J0IHthZGRTaGVsbENvbW1hbmRWYXJpYWJsZUluc3RydWN0aW9uc30gZnJvbSBcIi4vU2hlbGxDb21tYW5kVmFyaWFibGVJbnN0cnVjdGlvbnNcIjtcclxuaW1wb3J0IHtTaGVsbENvbW1hbmRWYXJpYWJsZX0gZnJvbSBcIi4vU2hlbGxDb21tYW5kVmFyaWFibGVcIjtcclxuLy8gQHRzLWlnbm9yZSBcImVsZWN0cm9uXCIgaXMgaW5zdGFsbGVkLlxyXG5pbXBvcnQge2NsaXBib2FyZH0gZnJvbSBcImVsZWN0cm9uXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgU2hlbGxDb21tYW5kVmFyaWFibGVfQ2xpcGJvYXJkIGV4dGVuZHMgU2hlbGxDb21tYW5kVmFyaWFibGUge1xyXG4gICAgbmFtZSA9IFwiY2xpcGJvYXJkXCI7XHJcblxyXG4gICAgZ2V0VmFsdWUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gY2xpcGJvYXJkLnJlYWRUZXh0KCk7XHJcbiAgICB9XHJcbn1cclxuYWRkU2hlbGxDb21tYW5kVmFyaWFibGVJbnN0cnVjdGlvbnMoXHJcbiAgICBcInt7Y2xpcGJvYXJkfX1cIixcclxuICAgIFwiR2l2ZXMgdGhlIGNvbnRlbnQgeW91IGxhc3QgY29waWVkIHRvIHlvdXIgY2xpcGJvYXJkLlwiLFxyXG4pOyIsImltcG9ydCB7YWRkU2hlbGxDb21tYW5kVmFyaWFibGVJbnN0cnVjdGlvbnN9IGZyb20gXCIuL1NoZWxsQ29tbWFuZFZhcmlhYmxlSW5zdHJ1Y3Rpb25zXCI7XHJcbmltcG9ydCB7bW9tZW50fSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtJUGFyYW1ldGVycywgU2hlbGxDb21tYW5kVmFyaWFibGV9IGZyb20gXCIuL1NoZWxsQ29tbWFuZFZhcmlhYmxlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgU2hlbGxDb21tYW5kVmFyaWFibGVfRGF0ZSBleHRlbmRzIFNoZWxsQ29tbWFuZFZhcmlhYmxlIHtcclxuICAgIG5hbWUgPSBcImRhdGVcIjtcclxuICAgIHByb3RlY3RlZCByZWFkb25seSBwYXJhbWV0ZXJzOiBJUGFyYW1ldGVycyA9IHtcclxuICAgICAgICBmb3JtYXQ6IHtcclxuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgYXJndW1lbnRzOiB7XHJcbiAgICAgICAgZm9ybWF0OiBzdHJpbmcsXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VmFsdWUoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50KCkuZm9ybWF0KHRoaXMuYXJndW1lbnRzLmZvcm1hdCk7XHJcbiAgICB9XHJcbn1cclxuYWRkU2hlbGxDb21tYW5kVmFyaWFibGVJbnN0cnVjdGlvbnMoXHJcbiAgICBcInt7ZGF0ZTpmb3JtYXR9fVwiLFxyXG4gICAgXCJHaXZlcyBhIGRhdGUvdGltZSBzdGFtcCBhcyBwZXIgeW91ciBsaWtpbmcuIFRoZSBcXFwiZm9ybWF0XFxcIiBwYXJ0IGNhbiBiZSBjdXN0b21pemVkIGFuZCBpcyBtYW5kYXRvcnkuIEZvcm1hdHRpbmcgb3B0aW9uczogaHR0cHM6Ly9tb21lbnRqcy5jb20vZG9jcy8jL2Rpc3BsYXlpbmcvZm9ybWF0L1wiLFxyXG4pOyIsImltcG9ydCB7YWRkU2hlbGxDb21tYW5kVmFyaWFibGVJbnN0cnVjdGlvbnN9IGZyb20gXCIuL1NoZWxsQ29tbWFuZFZhcmlhYmxlSW5zdHJ1Y3Rpb25zXCI7XHJcbmltcG9ydCB7Z2V0VmF1bHRBYnNvbHV0ZVBhdGh9IGZyb20gXCIuLi9Db21tb25cIjtcclxuaW1wb3J0IHtTaGVsbENvbW1hbmRWYXJpYWJsZX0gZnJvbSBcIi4vU2hlbGxDb21tYW5kVmFyaWFibGVcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBTaGVsbENvbW1hbmRWYXJpYWJsZV9WYXVsdFBhdGggZXh0ZW5kcyBTaGVsbENvbW1hbmRWYXJpYWJsZXtcclxuICAgIG5hbWUgPSBcInZhdWx0X3BhdGhcIjtcclxuICAgIGdldFZhbHVlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIGdldFZhdWx0QWJzb2x1dGVQYXRoKHRoaXMuYXBwKTtcclxuICAgIH1cclxufVxyXG5hZGRTaGVsbENvbW1hbmRWYXJpYWJsZUluc3RydWN0aW9ucyhcclxuICAgIFwie3t2YXVsdF9wYXRofX1cIixcclxuICAgIFwiR2l2ZXMgdGhlIE9ic2lkaWFuIHZhdWx0J3MgYWJzb2x1dGUgcGF0aCBmcm9tIHRoZSByb290IG9mIHRoZSBmaWxlc3lzdGVtLiBUaGlzIGlzIHRoZSBzYW1lIHRoYXQgaXMgdXNlZCBhcyBhIGRlZmF1bHQgd29ya2luZyBkaXJlY3RvcnkgaWYgeW91IGRvIG5vdCBkZWZpbmUgb25lIG1hbnVhbGx5LiBJZiB5b3UgZGVmaW5lIGEgd29ya2luZyBkaXJlY3RvcnkgbWFudWFsbHksIHRoaXMgdmFyaWFibGUgd29uJ3QgZ2l2ZSB5b3UgeW91ciBtYW51YWxseSBkZWZpbmVkIGRpcmVjdG9yeSwgaXQgYWx3YXlzIGdpdmVzIHRoZSB2YXVsdCdzIHJvb3QgZGlyZWN0b3J5LlwiLFxyXG4pOyIsImltcG9ydCB7YWRkU2hlbGxDb21tYW5kVmFyaWFibGVJbnN0cnVjdGlvbnN9IGZyb20gXCIuL1NoZWxsQ29tbWFuZFZhcmlhYmxlSW5zdHJ1Y3Rpb25zXCI7XHJcbmltcG9ydCB7U2hlbGxDb21tYW5kVmFyaWFibGV9IGZyb20gXCIuL1NoZWxsQ29tbWFuZFZhcmlhYmxlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgU2hlbGxDb21tYW5kVmFyaWFibGVfRmlsZU5hbWUgZXh0ZW5kcyBTaGVsbENvbW1hbmRWYXJpYWJsZXtcclxuICAgIG5hbWUgPSBcImZpbGVfbmFtZVwiO1xyXG4gICAgZ2V0VmFsdWUoKTogc3RyaW5nIHtcclxuICAgICAgICBsZXQgZmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcbiAgICAgICAgaWYgKCFmaWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmV3RXJyb3JNZXNzYWdlKFwiTm8gZmlsZSBpcyBhY3RpdmUgYXQgdGhlIG1vbWVudC4gT3BlbiBhIGZpbGUgb3IgY2xpY2sgYSBwYW5lIHRoYXQgaGFzIGEgZmlsZSBvcGVuLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIG51bGwgaW5kaWNhdGVzIHRoYXQgZ2V0dGluZyBhIHZhbHVlIGhhcyBmYWlsZWQgYW5kIHRoZSBjb21tYW5kIHNob3VsZCBub3QgYmUgZXhlY3V0ZWQuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaWxlLm5hbWU7XHJcbiAgICB9XHJcbn1cclxuYWRkU2hlbGxDb21tYW5kVmFyaWFibGVJbnN0cnVjdGlvbnMoXHJcbiAgICBcInt7ZmlsZV9uYW1lfX1cIixcclxuICAgIFwiR2l2ZXMgdGhlIGN1cnJlbnQgZmlsZSBuYW1lIHdpdGggYSBmaWxlIGV4dGVuc2lvbi4gSWYgeW91IG5lZWQgaXQgd2l0aG91dCB0aGUgZXh0ZW5zaW9uLCB1c2Uge3t0aXRsZX19IGluc3RlYWQuXCIsXHJcbik7IiwiaW1wb3J0IHthZGRTaGVsbENvbW1hbmRWYXJpYWJsZUluc3RydWN0aW9uc30gZnJvbSBcIi4vU2hlbGxDb21tYW5kVmFyaWFibGVJbnN0cnVjdGlvbnNcIjtcclxuaW1wb3J0IHtnZXRWYXVsdEFic29sdXRlUGF0aCwgbm9ybWFsaXplUGF0aDJ9IGZyb20gXCIuLi9Db21tb25cIjtcclxuaW1wb3J0IHtJUGFyYW1ldGVycywgU2hlbGxDb21tYW5kVmFyaWFibGV9IGZyb20gXCIuL1NoZWxsQ29tbWFuZFZhcmlhYmxlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgU2hlbGxDb21tYW5kVmFyaWFibGVfRm9sZGVyUGF0aCBleHRlbmRzIFNoZWxsQ29tbWFuZFZhcmlhYmxle1xyXG4gICAgbmFtZSA9IFwiZm9sZGVyX3BhdGhcIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgcGFyYW1ldGVyczogSVBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgbW9kZToge1xyXG4gICAgICAgICAgICBvcHRpb25zOiBbXCJhYnNvbHV0ZVwiLCBcInJlbGF0aXZlXCJdLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3RlY3RlZCBhcmd1bWVudHM6IHtcclxuICAgICAgICBtb2RlOiBzdHJpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VmFsdWUoKTogc3RyaW5nfG51bGwge1xyXG4gICAgICAgIGxldCBhY3RpdmVfZmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcbiAgICAgICAgaWYgKGFjdGl2ZV9maWxlKSB7XHJcbiAgICAgICAgICAgIGlmIChhY3RpdmVfZmlsZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBmb2xkZXIgPSBhY3RpdmVfZmlsZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuYXJndW1lbnRzLm1vZGUudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhYnNvbHV0ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplUGF0aDIoZ2V0VmF1bHRBYnNvbHV0ZVBhdGgodGhpcy5hcHApICsgXCIvXCIgKyBmb2xkZXIucGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlbGF0aXZlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb2xkZXIuaXNSb290KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ic2lkaWFuIEFQSSBkb2VzIG5vdCBnaXZlIGEgY29ycmVjdCBmb2xkZXIucGF0aCB2YWx1ZSBmb3IgdGhlIHZhdWx0J3Mgcm9vdCBmb2xkZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBTZWUgdGhpcyBkaXNjdXNzaW9uIGFuZCBhcHBseSBwb3NzaWJsZSBjaGFuZ2VzIGlmIHNvbWV0aGluZyB3aWxsIGNvbWUgdXA6IGh0dHBzOi8vZm9ydW0ub2JzaWRpYW4ubWQvdC92YXVsdC1yb290LWZvbGRlcnMtcmVsYXRpdmUtcGF0aC1naXZlcy8yNDg1N1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG5vcm1hbCBzdWJmb2xkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVQYXRoMihmb2xkZXIucGF0aCk7IC8vIE5vcm1hbGl6ZSB0byBnZXQgYSBjb3JyZWN0IHNsYXNoIGJldHdlZW4gZGlyZWN0b3JpZXMgZGVwZW5kaW5nIG9uIHBsYXRmb3JtLiBPbiBXaW5kb3dzIGl0IHNob3VsZCBiZSBcXCAuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubmV3RXJyb3JNZXNzYWdlKFwiVGhlIGN1cnJlbnQgZmlsZSBkb2VzIG5vdCBoYXZlIGEgcGFyZW50IGZvciBzb21lIHN0cmFuZ2UgcmVhc29uLlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBudWxsIGluZGljYXRlcyB0aGF0IGdldHRpbmcgYSB2YWx1ZSBoYXMgZmFpbGVkIGFuZCB0aGUgY29tbWFuZCBzaG91bGQgbm90IGJlIGV4ZWN1dGVkLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5uZXdFcnJvck1lc3NhZ2UoXCJObyBmaWxlIGlzIGFjdGl2ZSBhdCB0aGUgbW9tZW50LiBPcGVuIGEgZmlsZSBvciBjbGljayBhIHBhbmUgdGhhdCBoYXMgYSBmaWxlIG9wZW4uXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gbnVsbCBpbmRpY2F0ZXMgdGhhdCBnZXR0aW5nIGEgdmFsdWUgaGFzIGZhaWxlZCBhbmQgdGhlIGNvbW1hbmQgc2hvdWxkIG5vdCBiZSBleGVjdXRlZC5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuYWRkU2hlbGxDb21tYW5kVmFyaWFibGVJbnN0cnVjdGlvbnMoXHJcbiAgICBcInt7Zm9sZGVyX3BhdGg6cmVsYXRpdmV9fSBvciB7e2ZvbGRlcl9wYXRoOmFic29sdXRlfX1cIixcclxuICAgIFwiR2l2ZXMgcGF0aCB0byB0aGUgY3VycmVudCBmaWxlJ3MgcGFyZW50IGZvbGRlciwgZWl0aGVyIGFzIGFic29sdXRlIGZyb20gdGhlIHJvb3Qgb2YgdGhlIGZpbGUgc3lzdGVtLCBvciBhcyByZWxhdGl2ZSBmcm9tIHRoZSByb290IG9mIHRoZSBPYnNpZGlhbiB2YXVsdC5cIixcclxuKTsiLCJpbXBvcnQge2FkZFNoZWxsQ29tbWFuZFZhcmlhYmxlSW5zdHJ1Y3Rpb25zfSBmcm9tIFwiLi9TaGVsbENvbW1hbmRWYXJpYWJsZUluc3RydWN0aW9uc1wiO1xyXG5pbXBvcnQge0lQYXJhbWV0ZXJzLCBTaGVsbENvbW1hbmRWYXJpYWJsZX0gZnJvbSBcIi4vU2hlbGxDb21tYW5kVmFyaWFibGVcIjtcclxuaW1wb3J0IHtnZXRBbGxUYWdzfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHt1bmlxdWVBcnJheX0gZnJvbSBcIi4uL0NvbW1vblwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFNoZWxsQ29tbWFuZFZhcmlhYmxlX1RhZ3MgZXh0ZW5kcyBTaGVsbENvbW1hbmRWYXJpYWJsZSB7XHJcbiAgICBuYW1lID0gXCJ0YWdzXCI7XHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgcGFyYW1ldGVyczogSVBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgc2VwYXJhdG9yOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIGFyZ3VtZW50czoge1xyXG4gICAgICAgIHNlcGFyYXRvcjogc3RyaW5nLFxyXG4gICAgfTtcclxuXHJcbiAgICBnZXRWYWx1ZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIGxldCBhY3RpdmVfZmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcbiAgICAgICAgaWYgKGFjdGl2ZV9maWxlKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGRvIGhhdmUgYW4gYWN0aXZlIGZpbGVcclxuICAgICAgICAgICAgbGV0IGNhY2hlID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoYWN0aXZlX2ZpbGUpO1xyXG4gICAgICAgICAgICBsZXQgdGFnczogc3RyaW5nW10gPSB1bmlxdWVBcnJheShnZXRBbGxUYWdzKGNhY2hlKSk7IC8vIElmIGEgdGFnIGlzIGRlZmluZWQgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgZmlsZSwgZ2V0VGFncygpIHJldHVybnMgaXQgbXVsdGlwbGUgdGltZXMsIHNvIHVzZSB1bmlxdWVBcnJheSgpIHRvIGlyb24gb3V0IGR1cGxpY2F0ZXMuXHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgcHJlY2VkaW5nIGhhc2ggY2hhcmFjdGVycy4gRS5nLiAjdGFnIGJlY29tZXMgdGFnXHJcbiAgICAgICAgICAgIHRhZ3MuZm9yRWFjaCgodGFnOiBzdHJpbmcsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0YWdzW2luZGV4XSA9IHRhZy5yZXBsYWNlKFwiI1wiLCBcIlwiKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGFncy5qb2luKHRoaXMuYXJndW1lbnRzLnNlcGFyYXRvcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTm8gZmlsZSBpcyBhY3RpdmUgYXQgdGhlIG1vbWVudFxyXG4gICAgICAgICAgICB0aGlzLm5ld0Vycm9yTWVzc2FnZShcIk5vIGZpbGUgaXMgYWN0aXZlIGF0IHRoZSBtb21lbnQuIE9wZW4gYSBmaWxlIG9yIGNsaWNrIGEgcGFuZSB0aGF0IGhhcyBhIGZpbGUgb3Blbi5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBudWxsIGluZGljYXRlcyB0aGF0IGdldHRpbmcgYSB2YWx1ZSBoYXMgZmFpbGVkIGFuZCB0aGUgY29tbWFuZCBzaG91bGQgbm90IGJlIGV4ZWN1dGVkLlxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5hZGRTaGVsbENvbW1hbmRWYXJpYWJsZUluc3RydWN0aW9ucyhcclxuICAgIFwie3t0YWdzOnNlcGFyYXRvcn19XCIsXHJcbiAgICBcIkdpdmVzIGFsbCB0YWdzIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbm90ZS4gUmVwbGFjZSB0aGUgXFxcInNlcGFyYXRvclxcXCIgcGFydCB3aXRoIGEgY29tbWEsIHNwYWNlIG9yIHdoYXRldmVyIGNoYXJhY3RlcnMgeW91IHdhbnQgdG8gdXNlIGFzIGEgc2VwYXJhdG9yIGJldHdlZW4gdGFncy4gQSBzZXBhcmF0b3IgaXMgYWx3YXlzIG5lZWRlZCB0byBiZSBkZWZpbmVkLlwiLFxyXG4pOyIsImltcG9ydCB7YWRkU2hlbGxDb21tYW5kVmFyaWFibGVJbnN0cnVjdGlvbnN9IGZyb20gXCIuL1NoZWxsQ29tbWFuZFZhcmlhYmxlSW5zdHJ1Y3Rpb25zXCI7XHJcbmltcG9ydCB7U2hlbGxDb21tYW5kVmFyaWFibGV9IGZyb20gXCIuL1NoZWxsQ29tbWFuZFZhcmlhYmxlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgU2hlbGxDb21tYW5kVmFyaWFibGVfVGl0bGUgZXh0ZW5kcyBTaGVsbENvbW1hbmRWYXJpYWJsZXtcclxuICAgIG5hbWUgPSBcInRpdGxlXCI7XHJcbiAgICBnZXRWYWx1ZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIGxldCBhY3RpdmVfZmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcbiAgICAgICAgaWYgKGFjdGl2ZV9maWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVfZmlsZS5iYXNlbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5uZXdFcnJvck1lc3NhZ2UoXCJObyBmaWxlIGlzIGFjdGl2ZSBhdCB0aGUgbW9tZW50LiBPcGVuIGEgZmlsZSBvciBjbGljayBhIHBhbmUgdGhhdCBoYXMgYSBmaWxlIG9wZW4uXCIpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuYWRkU2hlbGxDb21tYW5kVmFyaWFibGVJbnN0cnVjdGlvbnMoXHJcbiAgICBcInt7dGl0bGV9fVwiLFxyXG4gICAgXCJHaXZlcyB0aGUgY3VycmVudCBmaWxlIG5hbWUgd2l0aG91dCBhIGZpbGUgZXh0ZW5zaW9uLiBJZiB5b3UgbmVlZCBpdCB3aXRoIHRoZSBleHRlbnNpb24sIHVzZSB7e2ZpbGVfbmFtZX19IGluc3RlYWQuXCIsXHJcbik7IiwiaW1wb3J0IHthZGRTaGVsbENvbW1hbmRWYXJpYWJsZUluc3RydWN0aW9uc30gZnJvbSBcIi4vU2hlbGxDb21tYW5kVmFyaWFibGVJbnN0cnVjdGlvbnNcIjtcclxuaW1wb3J0IHtTaGVsbENvbW1hbmRWYXJpYWJsZX0gZnJvbSBcIi4vU2hlbGxDb21tYW5kVmFyaWFibGVcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBTaGVsbENvbW1hbmRWYXJpYWJsZV9Xb3Jrc3BhY2UgZXh0ZW5kcyBTaGVsbENvbW1hbmRWYXJpYWJsZXtcclxuICAgIG5hbWUgPSBcIndvcmtzcGFjZVwiO1xyXG4gICAgZ2V0VmFsdWUoKTogc3RyaW5nIHtcclxuXHJcbiAgICAgICAgLy8gSWRlYSBob3cgdG8gYWNjZXNzIHRoZSB3b3Jrc3BhY2VzIHBsdWdpbiBpcyBjb3BpZWQgMjAyMS0wOS0xNSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9WaW56ZW50MDMvb2JzaWRpYW4tYWR2YW5jZWQtdXJpL2Jsb2IvZjdlZjgwZDUyNTI0ODEyNDJlNjk0OTYyMDhlOTI1ODc0MjA5ZjRhYS9tYWluLnRzI0wxNjgtTDE3OVxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgaW50ZXJuYWxQbHVnaW5zIGV4aXN0cyBhbHRob3VnaCBpdCdzIG5vdCBpbiBvYnNpZGlhbi5kLnRzLlxyXG4gICAgICAgIGxldCB3b3Jrc3BhY2VzX3BsdWdpbiA9IHRoaXMuYXBwLmludGVybmFsUGx1Z2lucz8ucGx1Z2lucz8ud29ya3NwYWNlcztcclxuICAgICAgICBpZiAoIXdvcmtzcGFjZXNfcGx1Z2luKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmV3RXJyb3JNZXNzYWdlKFwiV29ya3NwYWNlcyBjb3JlIHBsdWdpbiBpcyBub3QgZm91bmQgZm9yIHNvbWUgcmVhc29uLiBQbGVhc2UgcmFpc2UgYW4gaXNzdWUgaW4gR2l0SHViLlwiKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIXdvcmtzcGFjZXNfcGx1Z2luLmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5uZXdFcnJvck1lc3NhZ2UoXCJXb3Jrc3BhY2VzIGNvcmUgcGx1Z2luIGlzIG5vdCBlbmFibGVkLlwiKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCB3b3Jrc3BhY2VfbmFtZSA9IHdvcmtzcGFjZXNfcGx1Z2luLmluc3RhbmNlPy5hY3RpdmVXb3Jrc3BhY2U7XHJcbiAgICAgICAgaWYgKCF3b3Jrc3BhY2VfbmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLm5ld0Vycm9yTWVzc2FnZShcIkNvdWxkIG5vdCBmaWd1cmUgb3V0IHRoZSBjdXJyZW50IHdvcmtzcGFjZSdzIG5hbWUuIFByb2JhYmx5IHlvdSBoYXZlIG5vdCBsb2FkZWQgYSB3b3Jrc3BhY2UuIFlvdSBjYW4gZG8gaXQgZS5nLiB2aWEgXFxcIk1hbmFnZSB3b3Jrc3BhY2VzXFxcIiBmcm9tIHRoZSBsZWZ0IHNpZGUgcGFuZWwuXCIpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWxsIG9rXHJcbiAgICAgICAgcmV0dXJuIHdvcmtzcGFjZV9uYW1lO1xyXG4gICAgfVxyXG59XHJcbmFkZFNoZWxsQ29tbWFuZFZhcmlhYmxlSW5zdHJ1Y3Rpb25zKFxyXG4gICAgXCJ7e3dvcmtzcGFjZX19XCIsXHJcbiAgICBcIkdpdmVzIHRoZSBjdXJyZW50IHdvcmtzcGFjZSdzIG5hbWUsIGlmIHRoZSBXb3Jrc3BhY2VzIGNvcmUgcGx1Z2luIGlzIGVuYWJsZWQuXCIsXHJcbik7IiwiaW1wb3J0IHtTaGVsbENvbW1hbmRWYXJpYWJsZX0gZnJvbSBcIi4vU2hlbGxDb21tYW5kVmFyaWFibGVcIjtcclxuaW1wb3J0IFNoZWxsQ29tbWFuZHNQbHVnaW4gZnJvbSBcIi4uL21haW5cIjtcclxuaW1wb3J0IHtTaGVsbENvbW1hbmRWYXJpYWJsZV9Gb2xkZXJOYW1lfSBmcm9tIFwiLi9TaGVsbENvbW1hbmRWYXJpYWJsZV9Gb2xkZXJOYW1lXCI7XHJcbmltcG9ydCB7U2hlbGxDb21tYW5kVmFyaWFibGVfU2VsZWN0aW9ufSBmcm9tIFwiLi9TaGVsbENvbW1hbmRWYXJpYWJsZV9TZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtTaGVsbENvbW1hbmRWYXJpYWJsZV9GaWxlUGF0aH0gZnJvbSBcIi4vU2hlbGxDb21tYW5kVmFyaWFibGVfRmlsZVBhdGhcIjtcclxuaW1wb3J0IHtTaGVsbENvbW1hbmRWYXJpYWJsZV9DbGlwYm9hcmR9IGZyb20gXCIuL1NoZWxsQ29tbWFuZFZhcmlhYmxlX0NsaXBib2FyZFwiO1xyXG5pbXBvcnQge1NoZWxsQ29tbWFuZFZhcmlhYmxlX0RhdGV9IGZyb20gXCIuL1NoZWxsQ29tbWFuZFZhcmlhYmxlX0RhdGVcIjtcclxuaW1wb3J0IHtTaGVsbENvbW1hbmRWYXJpYWJsZV9WYXVsdFBhdGh9IGZyb20gXCIuL1NoZWxsQ29tbWFuZFZhcmlhYmxlX1ZhdWx0UGF0aFwiO1xyXG5pbXBvcnQge1NoZWxsQ29tbWFuZFZhcmlhYmxlX0ZpbGVOYW1lfSBmcm9tIFwiLi9TaGVsbENvbW1hbmRWYXJpYWJsZV9GaWxlTmFtZVwiO1xyXG5pbXBvcnQge1NoZWxsQ29tbWFuZFZhcmlhYmxlX0ZvbGRlclBhdGh9IGZyb20gXCIuL1NoZWxsQ29tbWFuZFZhcmlhYmxlX0ZvbGRlclBhdGhcIjtcclxuaW1wb3J0IHtTaGVsbENvbW1hbmRWYXJpYWJsZV9UYWdzfSBmcm9tIFwiLi9TaGVsbENvbW1hbmRWYXJpYWJsZV9UYWdzXCI7XHJcbmltcG9ydCB7U2hlbGxDb21tYW5kVmFyaWFibGVfVGl0bGV9IGZyb20gXCIuL1NoZWxsQ29tbWFuZFZhcmlhYmxlX1RpdGxlXCI7XHJcbmltcG9ydCB7U2hlbGxDb21tYW5kVmFyaWFibGVfV29ya3NwYWNlfSBmcm9tIFwiLi9TaGVsbENvbW1hbmRWYXJpYWJsZV9Xb3Jrc3BhY2VcIjtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gcGx1Z2luXHJcbiAqIEBwYXJhbSBjb21tYW5kXHJcbiAqIEByZXR1cm4gc3RyaW5nfHN0cmluZ1tdIElmIHBhcnNpbmcgZmFpbHMsIGFuIGFycmF5IG9mIHN0cmluZyBlcnJvciBtZXNzYWdlcyBpcyByZXR1cm5lZC4gSWYgdGhlIHBhcnNpbmcgc3VjY2VlZHMsIHRoZSBwYXJzZWQgc2hlbGwgY29tbWFuZCB3aWxsIGJlIHJldHVybmVkIGp1c3QgYXMgYSBzdHJpbmcsIG5vdCBpbiBhbiBhcnJheS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNoZWxsQ29tbWFuZFZhcmlhYmxlcyhwbHVnaW46IFNoZWxsQ29tbWFuZHNQbHVnaW4sIGNvbW1hbmQ6IHN0cmluZyk6IHN0cmluZyB8IHN0cmluZ1tdIHtcclxuICAgIGxldCBzaGVsbF92YXJpYWJsZXM6IFNoZWxsQ29tbWFuZFZhcmlhYmxlW10gPSBbXHJcbiAgICAgICAgbmV3IFNoZWxsQ29tbWFuZFZhcmlhYmxlX0NsaXBib2FyZChwbHVnaW4pLFxyXG4gICAgICAgIG5ldyBTaGVsbENvbW1hbmRWYXJpYWJsZV9EYXRlKHBsdWdpbiksXHJcbiAgICAgICAgbmV3IFNoZWxsQ29tbWFuZFZhcmlhYmxlX0ZpbGVOYW1lKHBsdWdpbiksXHJcbiAgICAgICAgbmV3IFNoZWxsQ29tbWFuZFZhcmlhYmxlX0ZpbGVQYXRoKHBsdWdpbiksXHJcbiAgICAgICAgbmV3IFNoZWxsQ29tbWFuZFZhcmlhYmxlX0ZvbGRlck5hbWUocGx1Z2luKSxcclxuICAgICAgICBuZXcgU2hlbGxDb21tYW5kVmFyaWFibGVfRm9sZGVyUGF0aChwbHVnaW4pLFxyXG4gICAgICAgIG5ldyBTaGVsbENvbW1hbmRWYXJpYWJsZV9TZWxlY3Rpb24ocGx1Z2luKSxcclxuICAgICAgICBuZXcgU2hlbGxDb21tYW5kVmFyaWFibGVfVGFncyhwbHVnaW4pLFxyXG4gICAgICAgIG5ldyBTaGVsbENvbW1hbmRWYXJpYWJsZV9UaXRsZShwbHVnaW4pLFxyXG4gICAgICAgIG5ldyBTaGVsbENvbW1hbmRWYXJpYWJsZV9WYXVsdFBhdGgocGx1Z2luKSxcclxuICAgICAgICBuZXcgU2hlbGxDb21tYW5kVmFyaWFibGVfV29ya3NwYWNlKHBsdWdpbiksXHJcbiAgICBdO1xyXG4gICAgbGV0IHBhcnNlZF9jb21tYW5kID0gY29tbWFuZDsgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgdmFyaWFibGUgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGFsdGVyIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiAnY29tbWFuZCcgZHVyaW5nIGl0ZXJhdGluZyBpdHMgcmVnZXggbWF0Y2hlcy5cclxuICAgIGZvciAobGV0IHZhcmlhYmxlX2luZGV4IGluIHNoZWxsX3ZhcmlhYmxlcylcclxuICAgIHtcclxuICAgICAgICBsZXQgdmFyaWFibGU6IFNoZWxsQ29tbWFuZFZhcmlhYmxlID0gc2hlbGxfdmFyaWFibGVzW3ZhcmlhYmxlX2luZGV4XTtcclxuICAgICAgICBsZXQgcGF0dGVybiA9IG5ldyBSZWdFeHAodmFyaWFibGUuZ2V0UGF0dGVybigpLCBcImlnXCIpOyAvLyBpOiBjYXNlLWluc2Vuc2l0aXZlOyBnOiBtYXRjaCBhbGwgb2NjdXJyZW5jZXMgaW5zdGVhZCBvZiBqdXN0IHRoZSBmaXJzdCBvbmUuXHJcbiAgICAgICAgY29uc3QgcGFyYW1ldGVyX25hbWVzID0gdmFyaWFibGUuZ2V0UGFyYW1ldGVyTmFtZXMoKTtcclxuICAgICAgICBsZXQgX2FyZ3VtZW50czogUmVnRXhwRXhlY0FycmF5OyAvLyBOZWVkIHRvIHByZWZpeCB3aXRoIF8gYmVjYXVzZSBKYXZhU2NyaXB0IHJlc2VydmVzIHRoZSB2YXJpYWJsZSBuYW1lICdhcmd1bWVudHMnLlxyXG4gICAgICAgIHdoaWxlICgoX2FyZ3VtZW50cyA9IHBhdHRlcm4uZXhlYyhjb21tYW5kKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3Vic3RpdHV0ZSA9IF9hcmd1bWVudHMuc2hpZnQoKTsgLy8gJ19hcmd1bWVudHNbMF0nIGNvbnRhaW5zIHRoZSB3aG9sZSBtYXRjaCwgbm90IGp1c3QgYW4gYXJndW1lbnQuIEdldCBpdCBhbmQgcmVtb3ZlIGl0IGZyb20gJ19hcmd1bWVudHMnLlxyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHN0dWZmIHRoYXQgc2hvdWxkIG5vdCBiZSBpdGVyYXRlZCBpbiB0aGUgbmV4dCBsb29wLlxyXG4gICAgICAgICAgICAvLyBcIklmIHRoZSBwcm9wZXJ0eSB3aGljaCB5b3UgYXJlIHRyeWluZyB0byBkZWxldGUgZG9lcyBub3QgZXhpc3QsIGRlbGV0ZSB3aWxsIG5vdCBoYXZlIGFueSBlZmZlY3QgYW5kIHdpbGwgcmV0dXJuIHRydWUuXCIgVGhpcyBpcyBnb29kLiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvZGVsZXRlXHJcbiAgICAgICAgICAgIGRlbGV0ZSBfYXJndW1lbnRzW1wiZ3JvdXBzXCJdO1xyXG4gICAgICAgICAgICBkZWxldGUgX2FyZ3VtZW50c1tcImluZGV4XCJdO1xyXG4gICAgICAgICAgICBkZWxldGUgX2FyZ3VtZW50c1tcImlucHV0XCJdO1xyXG5cclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSBhbGwgYXJndW1lbnRzXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgaW4gX2FyZ3VtZW50cykge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgYXJndW1lbnQgaXMgbm90IG9taXR0ZWQuIEl0IGNhbiBiZSBvbWl0dGVkICg9IHVuZGVmaW5lZCksIGlmIHRoZSBwYXJhbWV0ZXIgaXMgb3B0aW9uYWwuXHJcbiAgICAgICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBfYXJndW1lbnRzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGFyZ3VtZW50IGlzIHByZXNlbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJndW1lbnQgPSBfYXJndW1lbnRzW2ldLnNsaWNlKDEpOyAvLyAuc2xpY2UoMSk6IFJlbW92ZSBhIHByZWNlZGluZyA6XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVyX25hbWUgPSBwYXJhbWV0ZXJfbmFtZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGUuc2V0QXJndW1lbnQocGFyYW1ldGVyX25hbWUsIGFyZ3VtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSB2YXJpYWJsZVxyXG4gICAgICAgICAgICBsZXQgdmFyaWFibGVfdmFsdWUgPSB2YXJpYWJsZS5nZXRWYWx1ZSgpO1xyXG4gICAgICAgICAgICBpZiAodmFyaWFibGUuZ2V0RXJyb3JNZXNzYWdlcygpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgaGFzIGJlZW4gYSBwcm9ibGVtIGFuZCBleGVjdXRpbmcgdGhlIGNvbW1hbmQgc2hvdWxkIGJlIGNhbmNlbGxlZC5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUGFyc2luZyBjb21tYW5kIFwiICsgY29tbWFuZCArIFwiIGZhaWxlZC5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFyaWFibGUuZ2V0RXJyb3JNZXNzYWdlcygpOyAvLyBSZXR1cm5pbmcgbm93IHByZXZlbnRzIHBhcnNpbmcgcmVzdCBvZiB0aGUgdmFyaWFibGVzLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcGFyc2VkX2NvbW1hbmQgPSBwYXJzZWRfY29tbWFuZC5yZXBsYWNlKHN1YnN0aXR1dGUsIHZhcmlhYmxlX3ZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwYXJzZWRfY29tbWFuZDtcclxufVxyXG4iLCJpbXBvcnQge091dHB1dENoYW5uZWwsIE91dHB1dENoYW5uZWxPcmRlcn0gZnJvbSBcIi4uL291dHB1dF9jaGFubmVscy9PdXRwdXRDaGFubmVsXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNoZWxsQ29tbWFuZHNDb25maWd1cmF0aW9uIHtcclxuICAgIFtrZXk6IHN0cmluZ106IFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb247XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbiB7XHJcbiAgICBzaGVsbF9jb21tYW5kOiBzdHJpbmc7XHJcbiAgICBhbGlhczogc3RyaW5nO1xyXG4gICAgY29uZmlybV9leGVjdXRpb246IGJvb2xlYW47XHJcbiAgICBpZ25vcmVfZXJyb3JfY29kZXM6IG51bWJlcltdO1xyXG4gICAgb3V0cHV0X2NoYW5uZWxzOiB7XHJcbiAgICAgICAgc3Rkb3V0OiBPdXRwdXRDaGFubmVsLFxyXG4gICAgICAgIHN0ZGVycjogT3V0cHV0Q2hhbm5lbCxcclxuICAgIH0sXHJcbiAgICBvdXRwdXRfY2hhbm5lbF9vcmRlcjogT3V0cHV0Q2hhbm5lbE9yZGVyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbmV3U2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbihzaGVsbF9jb21tYW5kOiBzdHJpbmcgPSBcIlwiKTogU2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNoZWxsX2NvbW1hbmQ6IHNoZWxsX2NvbW1hbmQsXHJcbiAgICAgICAgYWxpYXM6IFwiXCIsXHJcbiAgICAgICAgY29uZmlybV9leGVjdXRpb246IGZhbHNlLFxyXG4gICAgICAgIGlnbm9yZV9lcnJvcl9jb2RlczogW10sXHJcbiAgICAgICAgb3V0cHV0X2NoYW5uZWxzOiB7XHJcbiAgICAgICAgICAgIHN0ZG91dDogXCJpZ25vcmVcIixcclxuICAgICAgICAgICAgc3RkZXJyOiBcIm5vdGlmaWNhdGlvblwiLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3V0cHV0X2NoYW5uZWxfb3JkZXI6IFwic3Rkb3V0LWZpcnN0XCIsXHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgU2hlbGxDb21tYW5kc1BsdWdpbiBmcm9tIFwiLi9tYWluXCI7XHJcbmltcG9ydCB7bmV3U2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vc2V0dGluZ3MvU2hlbGxDb21tYW5kQ29uZmlndXJhdGlvblwiO1xyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIFJ1bk1pZ3JhdGlvbnMocGx1Z2luOiBTaGVsbENvbW1hbmRzUGx1Z2luKSB7XHJcbiAgICBsZXQgc2F2ZSA9IE1pZ3JhdGVDb21tYW5kc1RvU2hlbGxDb21tYW5kcyhwbHVnaW4pO1xyXG4gICAgc2F2ZSB8fD0gRW5zdXJlU2hlbGxDb21tYW5kc0hhdmVBbGxGaWVsZHMocGx1Z2luKTtcclxuICAgIGlmIChzYXZlKSB7XHJcbiAgICAgICAgLy8gT25seSBzYXZlIGlmIHRoZXJlIHdlcmUgY2hhbmdlcyB0byBjb25maWd1cmF0aW9uLlxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2F2aW5nIG1pZ3JhdGlvbnMuLi5cIilcclxuICAgICAgICBhd2FpdCBwbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJNaWdyYXRpb25zIHNhdmVkLi4uXCIpXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE1pZ3JhdGVDb21tYW5kc1RvU2hlbGxDb21tYW5kcyhwbHVnaW46IFNoZWxsQ29tbWFuZHNQbHVnaW4pIHtcclxuICAgIGxldCBjb3VudF9zaGVsbF9jb21tYW5kcyA9IHBsdWdpbi5zZXR0aW5ncy5jb21tYW5kcy5sZW5ndGg7XHJcbiAgICBsZXQgc2F2ZSA9IGZhbHNlO1xyXG4gICAgaWYgKDAgPCBjb3VudF9zaGVsbF9jb21tYW5kcykge1xyXG4gICAgICAgIGxldCBjb3VudF9lbXB0eV9jb21tYW5kcyA9IDA7IC8vIEEgY291bnRlciBmb3IgZW1wdHkgb3IgbnVsbCBjb21tYW5kc1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwic2V0dGluZ3MuY29tbWFuZHMgaXMgbm90IGVtcHR5LCB3aWxsIG1pZ3JhdGUgXCIgKyBjb3VudF9zaGVsbF9jb21tYW5kcyArIFwiIGNvbW1hbmRzIHRvIHNldHRpbmdzLnNoZWxsX2NvbW1hbmRzLlwiKTtcclxuICAgICAgICBmb3IgKGxldCBzaGVsbF9jb21tYW5kX2lkIGluIHBsdWdpbi5zZXR0aW5ncy5jb21tYW5kcykge1xyXG4gICAgICAgICAgICBsZXQgc2hlbGxfY29tbWFuZCA9IHBsdWdpbi5zZXR0aW5ncy5jb21tYW5kc1tzaGVsbF9jb21tYW5kX2lkXTtcclxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGNvbW1hbmQgaXMgbm90IGVtcHR5LiBKdXN0IGluIGNhc2UuXHJcbiAgICAgICAgICAgIGlmIChudWxsID09PSBzaGVsbF9jb21tYW5kIHx8IDAgPT09IHNoZWxsX2NvbW1hbmQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgY29tbWFuZCBpcyBlbXB0eVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJNaWdyYXRpb24gZmFpbHVyZSBmb3Igc2hlbGwgY29tbWFuZCAjXCIgKyBzaGVsbF9jb21tYW5kX2lkICsgXCI6IFRoZSBvcmlnaW5hbCBzaGVsbCBjb21tYW5kIHN0cmluZyBpcyBlbXB0eSwgc28gaXQgY2Fubm90IGJlIG1pZ3JhdGVkLlwiKTtcclxuICAgICAgICAgICAgICAgIGNvdW50X2VtcHR5X2NvbW1hbmRzKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodW5kZWZpbmVkICE9PSBwbHVnaW4uc2V0dGluZ3Muc2hlbGxfY29tbWFuZHNbc2hlbGxfY29tbWFuZF9pZF0pIHtcclxuICAgICAgICAgICAgICAgIC8vIEEgY29tbWFuZCB3aXRoIHRoZSBzYW1lIGlkIGFscmVhZHkgZXhpc3RzXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1pZ3JhdGlvbiBmYWlsdXJlIGZvciBzaGVsbCBjb21tYW5kICNcIiArIHNoZWxsX2NvbW1hbmRfaWQgKyBcIjogQSBzaGVsbCBjb21tYW5kIHdpdGggc2FtZSBJRCBhbHJlYWR5IGV4aXN0cyBpbiBzZXR0aW5ncy5zaGVsbF9jb21tYW5kcy5cIik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBbGwgT0ssIG1pZ3JhdGUuXHJcbiAgICAgICAgICAgICAgICBwbHVnaW4uc2V0dGluZ3Muc2hlbGxfY29tbWFuZHNbc2hlbGxfY29tbWFuZF9pZF0gPSBuZXdTaGVsbENvbW1hbmRDb25maWd1cmF0aW9uKHNoZWxsX2NvbW1hbmQpOyAvLyBDcmVhdGVzIGEgc2hlbGwgY29tbWFuZCB3aXRoIGRlZmF1bHQgdmFsdWVzIGFuZCBkZWZpbmVzIHRoZSBjb21tYW5kIGZvciBpdC5cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBwbHVnaW4uc2V0dGluZ3MuY29tbWFuZHNbc2hlbGxfY29tbWFuZF9pZF07IC8vIExlYXZlcyBhIG51bGwgaW4gcGxhY2UsIGJ1dCB3ZSBjYW4gZGVhbCB3aXRoIGl0IGJ5IGRlbGV0aW5nIHRoZSB3aG9sZSBhcnJheSBpZiBpdCBnZXRzIGVtcHR5LlxyXG4gICAgICAgICAgICAgICAgY291bnRfZW1wdHlfY29tbWFuZHMrKzsgLy8gQWNjb3VudCB0aGUgbnVsbCBnZW5lcmF0ZWQgb24gdGhlIHByZXZpb3VzIGxpbmUuXHJcbiAgICAgICAgICAgICAgICBzYXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTWlncmF0ZWQgc2hlbGwgY29tbWFuZCAjXCIgKyBzaGVsbF9jb21tYW5kX2lkICsgXCI6IFwiICsgc2hlbGxfY29tbWFuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvdW50X2VtcHR5X2NvbW1hbmRzID09PSBjb3VudF9zaGVsbF9jb21tYW5kcykge1xyXG4gICAgICAgICAgICAvLyBUaGUgd2hvbGUgY29tbWFuZHMgYXJyYXkgbm93IGNvbnRhaW5zIG9ubHkgZW1wdHkvbnVsbCBjb21tYW5kcy5cclxuICAgICAgICAgICAgLy8gRGVsZXRlIGl0LlxyXG4gICAgICAgICAgICBkZWxldGUgcGx1Z2luLnNldHRpbmdzLmNvbW1hbmRzO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJzZXR0aW5ncy5jb21tYW5kcyBpcyBlbXB0eSwgc28gbm8gbmVlZCB0byBtaWdyYXRlIGNvbW1hbmRzLiBHb29kIHRoaW5nISA6KVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzYXZlO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBpcyBhIGdlbmVyYWwgbWlncmF0b3IgdGhhdCBhZGRzIG5ldywgbWlzc2luZyBwcm9wZXJ0aWVzIHRvIFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb24gb2JqZWN0cy4gVGhpcyBpcyBub3QgdGllZCB0byBhbnkgc3BlY2lmaWMgdmVyc2lvbiB1cGRhdGUsIHVubGlrZSBNaWdyYXRlQ29tbWFuZHNUb1NoZWxsQ29tbWFuZHMoKS5cclxuICpcclxuICogQHBhcmFtIHBsdWdpblxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEVuc3VyZVNoZWxsQ29tbWFuZHNIYXZlQWxsRmllbGRzKHBsdWdpbjogU2hlbGxDb21tYW5kc1BsdWdpbikge1xyXG4gICAgbGV0IHNhdmUgPSBmYWxzZTtcclxuICAgIGxldCBzaGVsbF9jb21tYW5kX2RlZmF1bHRfY29uZmlndXJhdGlvbiA9IG5ld1NoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb24oKTtcclxuICAgIGxldCBzaGVsbF9jb21tYW5kX2lkOiBzdHJpbmc7XHJcbiAgICBsZXQgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9ucyA9IHBsdWdpbi5nZXRTaGVsbENvbW1hbmRzKCk7XHJcbiAgICBmb3IgKHNoZWxsX2NvbW1hbmRfaWQgaW4gc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9ucykge1xyXG4gICAgICAgIGxldCBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24gPSBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb25zW3NoZWxsX2NvbW1hbmRfaWRdO1xyXG4gICAgICAgIGZvciAobGV0IHByb3BlcnR5X25hbWUgaW4gc2hlbGxfY29tbWFuZF9kZWZhdWx0X2NvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBwcm9wZXJ0eV9kZWZhdWx0X3ZhbHVlIGNhbiBoYXZlIChhbG1vc3QpIHdoYXRldmVyIGRhdGF0eXBlXHJcbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eV9kZWZhdWx0X3ZhbHVlOiBhbnkgPSBzaGVsbF9jb21tYW5kX2RlZmF1bHRfY29uZmlndXJhdGlvbltwcm9wZXJ0eV9uYW1lXTtcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb25bcHJvcGVydHlfbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hlbGwgY29tbWFuZCBkb2VzIG5vdCBoYXZlIHRoaXMgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHByb3BlcnR5IHRvIHRoZSBzaGVsbCBjb21tYW5kIGFuZCB1c2UgYSBkZWZhdWx0IHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFbnN1cmVTaGVsbENvbW1hbmRzSGF2ZUFsbEZpZWxkcygpOiBTaGVsbCBjb21tYW5kICNcIiArIHNoZWxsX2NvbW1hbmRfaWQgKyBcIiBkb2VzIG5vdCBoYXZlIHByb3BlcnR5ICdcIiArIHByb3BlcnR5X25hbWUgKyBcIicuIFdpbGwgY3JlYXRlIHRoZSBwcm9wZXJ0eSBhbmQgYXNzaWduIGEgZGVmYXVsdCB2YWx1ZSAnXCIgKyBwcm9wZXJ0eV9kZWZhdWx0X3ZhbHVlICsgXCInLlwiKTtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgICAgIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbltwcm9wZXJ0eV9uYW1lXSA9IHByb3BlcnR5X2RlZmF1bHRfdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBzYXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzYXZlO1xyXG59IiwiLy8gU0VUVElOR1MgQU5EIERFRkFVTFQgVkFMVUVTXHJcbmltcG9ydCB7U2hlbGxDb21tYW5kc0NvbmZpZ3VyYXRpb259IGZyb20gXCIuL1NoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb25cIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2hlbGxDb21tYW5kc1BsdWdpblNldHRpbmdzIHtcclxuICAgIHdvcmtpbmdfZGlyZWN0b3J5OiBzdHJpbmc7XHJcbiAgICBwcmV2aWV3X3ZhcmlhYmxlc19pbl9jb21tYW5kX3BhbGV0dGU6IGJvb2xlYW47XHJcbiAgICBzaGVsbF9jb21tYW5kczogU2hlbGxDb21tYW5kc0NvbmZpZ3VyYXRpb247XHJcbiAgICBlcnJvcl9tZXNzYWdlX2R1cmF0aW9uOiBudW1iZXI7XHJcbiAgICBub3RpZmljYXRpb25fbWVzc2FnZV9kdXJhdGlvbjogbnVtYmVyO1xyXG5cclxuICAgIC8vIExlZ2FjeTpcclxuICAgIC8qKiBAZGVwcmVjYXRlZCBVc2Ugc2hlbGxfY29tbWFuZHMgb2JqZWN0IGluc3RlYWQgb2YgdGhpcyBhcnJheS4gRnJvbSBub3cgb24sIHRoaXMgYXJyYXkgY2FuIGJlIHVzZWQgb25seSBmb3IgbWlncmF0aW5nIG9sZCBjb25maWd1cmF0aW9uIHRvIHNoZWxsX2NvbW1hbmRzLiovXHJcbiAgICBjb21tYW5kczogc3RyaW5nW107XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBTaGVsbENvbW1hbmRzUGx1Z2luU2V0dGluZ3MgPSB7XHJcbiAgICB3b3JraW5nX2RpcmVjdG9yeTogXCJcIixcclxuICAgIHByZXZpZXdfdmFyaWFibGVzX2luX2NvbW1hbmRfcGFsZXR0ZTogdHJ1ZSxcclxuICAgIHNoZWxsX2NvbW1hbmRzOiB7fSxcclxuICAgIGVycm9yX21lc3NhZ2VfZHVyYXRpb246IDIwLFxyXG4gICAgbm90aWZpY2F0aW9uX21lc3NhZ2VfZHVyYXRpb246IDEwLFxyXG5cclxuICAgIC8vIExlZ2FjeTpcclxuICAgIGNvbW1hbmRzOiBbXSAvLyBEZXByZWNhdGVkLCBidXQgbXVzdCBiZSBwcmVzZW50IGluIHRoZSBkZWZhdWx0IHZhbHVlcyBhcyBsb25nIGFzIG1pZ3JhdGluZyBmcm9tIGNvbW1hbmRzIHRvIHNoZWxsX2NvbW1hbmRzIGlzIHN1cHBvcnRlZC5cclxufSIsImltcG9ydCBTaGVsbENvbW1hbmRzUGx1Z2luIGZyb20gXCIuLi9tYWluXCI7XHJcbmltcG9ydCB7QXBwfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtPdXRwdXRTdHJlYW1zfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsRHJpdmVyRnVuY3Rpb25zXCI7XHJcbmltcG9ydCB7T3V0cHV0U3RyZWFtfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsXCI7XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgT3V0cHV0Q2hhbm5lbERyaXZlciB7XHJcbiAgICAvKipcclxuICAgICAqIEh1bWFuIHJlYWRhYmxlIG5hbWUsIHVzZWQgaW4gc2V0dGluZ3MuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCByZWFkb25seSB0aXRsZTogc3RyaW5nO1xyXG5cclxuICAgIHByb3RlY3RlZCBwbHVnaW46IFNoZWxsQ29tbWFuZHNQbHVnaW47XHJcbiAgICBwcm90ZWN0ZWQgYXBwOiBBcHA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW4gYmUgb3ZlcnJpZGRlbiBpbiBjaGlsZCBjbGFzc2VzIGluIG9yZGVyIHRvIHZhcnkgdGhlIHRpdGxlIGRlcGVuZGluZyBvbiBvdXRwdXRfc3RyZWFtLlxyXG4gICAgICogQHBhcmFtIG91dHB1dF9zdHJlYW1cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFRpdGxlKG91dHB1dF9zdHJlYW06IE91dHB1dFN0cmVhbSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRpdGxlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpbml0aWFsaXplKHBsdWdpbjogU2hlbGxDb21tYW5kc1BsdWdpbikge1xyXG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG4gICAgICAgIHRoaXMuYXBwID0gcGx1Z2luLmFwcDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgaGFuZGxlKG91dHB1dDogT3V0cHV0U3RyZWFtcywgZXJyb3JfY29kZTogbnVtYmVyfG51bGwpOiB2b2lkO1xyXG59IiwiaW1wb3J0IHtPdXRwdXRDaGFubmVsRHJpdmVyfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsRHJpdmVyXCI7XHJcbmltcG9ydCB7T3V0cHV0U3RyZWFtc30gZnJvbSBcIi4vT3V0cHV0Q2hhbm5lbERyaXZlckZ1bmN0aW9uc1wiO1xyXG5pbXBvcnQge091dHB1dFN0cmVhbX0gZnJvbSBcIi4vT3V0cHV0Q2hhbm5lbFwiO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBPdXRwdXRDaGFubmVsRHJpdmVyX05vdGlmaWNhdGlvbiBleHRlbmRzIE91dHB1dENoYW5uZWxEcml2ZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBOb3QgdXNlZCBiZWNhdXNlIGdldFRpdGxlKCkgZXhpc3RzLCBidXQgbXVzdCBiZSBwcmVzZW50LlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgdGl0bGU6IHN0cmluZztcclxuXHJcbiAgICBwdWJsaWMgZ2V0VGl0bGUob3V0cHV0X3N0cmVhbTogT3V0cHV0U3RyZWFtKTogc3RyaW5nIHtcclxuICAgICAgICBzd2l0Y2ggKG91dHB1dF9zdHJlYW0pIHtcclxuICAgICAgICAgICAgY2FzZSBcInN0ZG91dFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiTm90aWZpY2F0aW9uIGJhbGxvb25cIjtcclxuICAgICAgICAgICAgY2FzZSBcInN0ZGVyclwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiRXJyb3IgYmFsbG9vblwiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaGFuZGxlKG91dHB1dDogT3V0cHV0U3RyZWFtcywgZXJyb3JfY29kZTogbnVtYmVyfG51bGwpIHtcclxuXHJcbiAgICAgICAgLy8gSXRlcmF0ZSBvdXRwdXQgc3RyZWFtcy5cclxuICAgICAgICAvLyBUaGVyZSBjYW4gYmUgYm90aCBcInN0ZG91dFwiIGFuZCBcInN0ZGVyclwiIHByZXNlbnQgYXQgdGhlIHNhbWUgdGltZSwgb3IganVzdCBvbmUgb2YgdGhlbS4gSWYgYm90aCBhcmUgcHJlc2VudCwgdHdvXHJcbiAgICAgICAgLy8gbm90aWZpY2F0aW9ucyB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgICAgbGV0IG91dHB1dF9zdHJlYW1fbmFtZTogT3V0cHV0U3RyZWFtO1xyXG4gICAgICAgIGZvciAob3V0cHV0X3N0cmVhbV9uYW1lIGluIG91dHB1dCkge1xyXG4gICAgICAgICAgICBsZXQgb3V0cHV0X21lc3NhZ2UgPSBvdXRwdXRbb3V0cHV0X3N0cmVhbV9uYW1lXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvdXRwdXRfc3RyZWFtX25hbWUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJzdGRvdXRcIjpcclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3JtYWwgb3V0cHV0XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4ubmV3Tm90aWZpY2F0aW9uKG91dHB1dF9tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJzdGRlcnJcIjpcclxuICAgICAgICAgICAgICAgICAgICAvLyBFcnJvciBvdXRwdXRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5uZXdFcnJvcihcIltcIiArIGVycm9yX2NvZGUgKyBcIl06IFwiICsgb3V0cHV0X21lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IHtPdXRwdXRDaGFubmVsRHJpdmVyfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsRHJpdmVyXCI7XHJcbmltcG9ydCB7Z2V0RWRpdG9yLCBnZXRWaWV3LCBqb2luT2JqZWN0UHJvcGVydGllc30gZnJvbSBcIi4uL0NvbW1vblwiO1xyXG5pbXBvcnQge091dHB1dFN0cmVhbXN9IGZyb20gXCIuL091dHB1dENoYW5uZWxEcml2ZXJGdW5jdGlvbnNcIjtcclxuaW1wb3J0IHtFZGl0b3J9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIE91dHB1dENoYW5uZWxEcml2ZXJfQ3VycmVudEZpbGUgZXh0ZW5kcyBPdXRwdXRDaGFubmVsRHJpdmVyIHtcclxuXHJcbiAgICBwdWJsaWMgaGFuZGxlKG91dHB1dDogT3V0cHV0U3RyZWFtcykge1xyXG4gICAgICAgIGxldCBlZGl0b3IgPSBnZXRFZGl0b3IodGhpcy5hcHApO1xyXG4gICAgICAgIGxldCB2aWV3ID0gZ2V0Vmlldyh0aGlzLmFwcCk7XHJcblxyXG4gICAgICAgIC8vIFRoZXJlIGNhbiBiZSBib3RoIFwic3Rkb3V0XCIgYW5kIFwic3RkZXJyXCIgcHJlc2VudCBhdCB0aGUgc2FtZSB0aW1lLCBvciBqdXN0IG9uZSBvZiB0aGVtLiBJZiBib3RoIGFyZSBwcmVzZW50LCB0aGV5XHJcbiAgICAgICAgLy8gd2lsbCBiZSBqb2luZWQgdG9nZXRoZXIgd2l0aCBcIiBcIiBhcyBhIHNlcGFyYXRvci5cclxuICAgICAgICBsZXQgb3V0cHV0X21lc3NhZ2UgPSBqb2luT2JqZWN0UHJvcGVydGllcyhvdXRwdXQsIFwiIFwiKTtcclxuXHJcbiAgICAgICAgaWYgKG51bGwgPT09IGVkaXRvcikge1xyXG4gICAgICAgICAgICAvLyBGb3Igc29tZSByZWFzb24gaXQncyBub3QgcG9zc2libGUgdG8gZ2V0IGFuIGVkaXRvci5cclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4ubmV3RXJyb3IoXCJDb3VsZCBub3QgZ2V0IGFuIGVkaXRvciBpbnN0YW5jZSEgUGxlYXNlIHJhaXNlIGFuIGlzc3VlIGluIEdpdEh1Yi4gVGhlIGNvbW1hbmQgb3V0cHV0IGlzIGluIHRoZSBuZXh0IGVycm9yIGJveDpcIik7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLm5ld0Vycm9yKG91dHB1dF9tZXNzYWdlKTsgLy8gR29vZCB0byBvdXRwdXQgaXQgYXQgbGVhc3Qgc29tZSB3YXkuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiT3V0cHV0Q2hhbm5lbERyaXZlcl9DdXJyZW50RmlsZTogQ291bGQgbm90IGdldCBhbiBlZGl0b3IgaW5zdGFuY2UuXCIpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSB2aWV3IGlzIGluIHNvdXJjZSBtb2RlXHJcbiAgICAgICAgaWYgKG51bGwgPT09IHZpZXcpIHtcclxuICAgICAgICAgICAgLy8gRm9yIHNvbWUgcmVhc29uIGl0J3Mgbm90IHBvc3NpYmxlIHRvIGdldCBhbiBlZGl0b3IsIGJ1dCBpdCdzIG5vdCBhIGJpZyBwcm9ibGVtLlxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk91dHB1dENoYW5uZWxEcml2ZXJfQ3VycmVudEZpbGU6IENvdWxkIG5vdCBnZXQgYSB2aWV3IGluc3RhbmNlLlwiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBXZSBkbyBoYXZlIGEgdmlld1xyXG4gICAgICAgICAgICBpZiAoXCJzb3VyY2VcIiAhPT0gdmlldy5nZXRNb2RlKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdhcm4gdGhhdCB0aGUgb3V0cHV0IG1pZ2h0IGdvIHRvIGFuIHVuZXhwZWN0ZWQgcGxhY2UgaW4gdGhlIG5vdGUgZmlsZS5cclxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLm5ld05vdGlmaWNhdGlvbihcIk5vdGUgdGhhdCB5b3VyIGFjdGl2ZSBub3RlIGlzIG5vdCBpbiAnRWRpdCcgbW9kZSEgVGhlIG91dHB1dCBjb21lcyB2aXNpYmxlIHdoZW4geW91IHN3aXRjaCB0byAnRWRpdCcgbW9kZSBhZ2FpbiFcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEluc2VydCBpbnRvIHRoZSBjdXJyZW50IGZpbGVcclxuICAgICAgICB0aGlzLmluc2VydEludG9FZGl0b3IoZWRpdG9yLCBvdXRwdXRfbWVzc2FnZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGluc2VydEludG9FZGl0b3IoZWRpdG9yOiBFZGl0b3IsIG91dHB1dF9tZXNzYWdlOiBzdHJpbmcpOiB2b2lkO1xyXG59IiwiaW1wb3J0IHtPdXRwdXRDaGFubmVsRHJpdmVyX0N1cnJlbnRGaWxlfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsRHJpdmVyX0N1cnJlbnRGaWxlXCI7XHJcbmltcG9ydCB7RWRpdG9yfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBPdXRwdXRDaGFubmVsRHJpdmVyX0N1cnJlbnRGaWxlQ2FyZXQgZXh0ZW5kcyBPdXRwdXRDaGFubmVsRHJpdmVyX0N1cnJlbnRGaWxlIHtcclxuICAgIHByb3RlY3RlZCByZWFkb25seSB0aXRsZSA9IFwiQ3VycmVudCBmaWxlOiBjYXJldCBwb3NpdGlvblwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0cyB0ZXh0IGludG8gdGhlIGdpdmVuIGVkaXRvciwgYXQgY2FyZXQgcG9zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVkaXRvclxyXG4gICAgICogQHBhcmFtIG91dHB1dF9tZXNzYWdlXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBpbnNlcnRJbnRvRWRpdG9yKGVkaXRvcjogRWRpdG9yLCBvdXRwdXRfbWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgZWRpdG9yLnJlcGxhY2VTZWxlY3Rpb24ob3V0cHV0X21lc3NhZ2UpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHtPdXRwdXRDaGFubmVsRHJpdmVyX0N1cnJlbnRGaWxlfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsRHJpdmVyX0N1cnJlbnRGaWxlXCI7XHJcbmltcG9ydCB7RWRpdG9yfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBPdXRwdXRDaGFubmVsRHJpdmVyX0N1cnJlbnRGaWxlVG9wIGV4dGVuZHMgT3V0cHV0Q2hhbm5lbERyaXZlcl9DdXJyZW50RmlsZSB7XHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgdGl0bGUgPSBcIkN1cnJlbnQgZmlsZTogdG9wXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnRzIHRleHQgaW50byB0aGUgZ2l2ZW4gZWRpdG9yLCBhdCB0b3AuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVkaXRvclxyXG4gICAgICogQHBhcmFtIG91dHB1dF9tZXNzYWdlXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBpbnNlcnRJbnRvRWRpdG9yKGVkaXRvcjogRWRpdG9yLCBvdXRwdXRfbWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgdG9wX3Bvc2l0aW9uID0gZWRpdG9yLm9mZnNldFRvUG9zKDApO1xyXG4gICAgICAgIGVkaXRvci5yZXBsYWNlUmFuZ2Uob3V0cHV0X21lc3NhZ2UsIHRvcF9wb3NpdGlvbik7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQge091dHB1dENoYW5uZWxEcml2ZXJ9IGZyb20gXCIuL091dHB1dENoYW5uZWxEcml2ZXJcIjtcclxuaW1wb3J0IHtPdXRwdXRTdHJlYW1zfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsRHJpdmVyRnVuY3Rpb25zXCI7XHJcbmltcG9ydCB7am9pbk9iamVjdFByb3BlcnRpZXN9IGZyb20gXCIuLi9Db21tb25cIjtcclxuaW1wb3J0IHtFT0x9IGZyb20gXCJvc1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIE91dHB1dENoYW5uZWxEcml2ZXJfU3RhdHVzQmFyIGV4dGVuZHMgT3V0cHV0Q2hhbm5lbERyaXZlciB7XHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgdGl0bGUgPSBcIlN0YXR1cyBiYXJcIjtcclxuXHJcbiAgICBwcml2YXRlIHN0YXR1c19iYXJfZWxlbWVudDogSFRNTEVsZW1lbnQ7XHJcblxyXG4gICAgcHVibGljIGhhbmRsZShvdXRwdXQ6IE91dHB1dFN0cmVhbXMpIHtcclxuICAgICAgICBjb25zdCBzdGF0dXNfYmFyX2VsZW1lbnQgPSB0aGlzLmdldFN0YXR1c0JhckVsZW1lbnQoKTtcclxuXHJcbiAgICAgICAgLy8gQ29tYmluZSBzdGRvdXQgYW5kIHN0ZGVyciAoaW4gY2FzZSBib3RoIG9mIHRoZW0gaGFwcGVuIHRvIGJlIHByZXNlbnQpLlxyXG4gICAgICAgIGxldCBzdGRvdXRfYW5kX3N0ZGVyciA9IGpvaW5PYmplY3RQcm9wZXJ0aWVzKG91dHB1dCwgRU9MICsgRU9MKS50cmltKCk7XHJcblxyXG4gICAgICAgIC8vIEZ1bGwgb3V0cHV0IChzaG93biB3aGVuIGhvdmVyaW5nIHdpdGggbW91c2UpXHJcbiAgICAgICAgc3RhdHVzX2Jhcl9lbGVtZW50LnNldEF0dHIoXCJhcmlhLWxhYmVsXCIsIHN0ZG91dF9hbmRfc3RkZXJyKTtcclxuXHJcbiAgICAgICAgLy8gU2hvdyBsYXN0IGxpbmUgcGVybWFuZW50bHkuXHJcbiAgICAgICAgY29uc3Qgb3V0cHV0X21lc3NhZ2VfbGluZXMgPSBzdGRvdXRfYW5kX3N0ZGVyci5zcGxpdCgvKFxcclxcbnxcXHJ8XFxuKS8pO1xyXG4gICAgICAgIGNvbnN0IGxhc3Rfb3V0cHV0X2xpbmUgPSBvdXRwdXRfbWVzc2FnZV9saW5lc1tvdXRwdXRfbWVzc2FnZV9saW5lcy5sZW5ndGggLSAxXTtcclxuICAgICAgICBzdGF0dXNfYmFyX2VsZW1lbnQuc2V0VGV4dChsYXN0X291dHB1dF9saW5lKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldFN0YXR1c0JhckVsZW1lbnQoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnN0YXR1c19iYXJfZWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXR1c19iYXJfZWxlbWVudCA9IHRoaXMucGx1Z2luLmFkZFN0YXR1c0Jhckl0ZW0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzX2Jhcl9lbGVtZW50O1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHtPdXRwdXRDaGFubmVsRHJpdmVyX0N1cnJlbnRGaWxlfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsRHJpdmVyX0N1cnJlbnRGaWxlXCI7XHJcbmltcG9ydCB7RWRpdG9yLCBFZGl0b3JQb3NpdGlvbn0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgT3V0cHV0Q2hhbm5lbERyaXZlcl9DdXJyZW50RmlsZUJvdHRvbSBleHRlbmRzIE91dHB1dENoYW5uZWxEcml2ZXJfQ3VycmVudEZpbGUge1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IHRpdGxlID0gXCJDdXJyZW50IGZpbGU6IGJvdHRvbVwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0cyB0ZXh0IGludG8gdGhlIGdpdmVuIGVkaXRvciwgYXQgYm90dG9tLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlZGl0b3JcclxuICAgICAqIEBwYXJhbSBvdXRwdXRfbWVzc2FnZVxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgaW5zZXJ0SW50b0VkaXRvcihlZGl0b3I6IEVkaXRvciwgb3V0cHV0X21lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbV9wb3NpdGlvbjogRWRpdG9yUG9zaXRpb24gPSB7XHJcbiAgICAgICAgICAgIGNoOiBlZGl0b3IuZ2V0TGluZShlZGl0b3IubGFzdExpbmUoKSkubGVuZ3RoLCAgIC8vIFRoZSBsYXN0IGNoYXJhY3Rlciogb2YgLi4uXHJcbiAgICAgICAgICAgIGxpbmU6IGVkaXRvci5sYXN0TGluZSgpLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLiB0aGUgbGFzdCBsaW5lLlxyXG4gICAgICAgIH07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAqKSBCdXQgZG8gbm90IHN1YnRyYWN0IDEsIGJlY2F1c2UgY2ggaXMgemVyby1iYXNlZCwgc28gd2hlbiAubGVuZ3RoIGlzIHVzZWQgd2l0aG91dCAtMSwgd2UgYXJlIHBvaW50aW5nIEFGVEVSIHRoZSBsYXN0IGNoYXJhY3Rlci5cclxuICAgICAgICBlZGl0b3IucmVwbGFjZVJhbmdlKG91dHB1dF9tZXNzYWdlLCBib3R0b21fcG9zaXRpb24pO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHtPdXRwdXRDaGFubmVsRHJpdmVyfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsRHJpdmVyXCI7XHJcbmltcG9ydCB7am9pbk9iamVjdFByb3BlcnRpZXN9IGZyb20gXCIuLi9Db21tb25cIjtcclxuaW1wb3J0IHtPdXRwdXRTdHJlYW1zfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsRHJpdmVyRnVuY3Rpb25zXCI7XHJcbi8vIEB0cy1pZ25vcmUgXCJlbGVjdHJvblwiIGlzIGluc3RhbGxlZC5cclxuaW1wb3J0IHtjbGlwYm9hcmR9IGZyb20gXCJlbGVjdHJvblwiO1xyXG5pbXBvcnQge0VPTH0gZnJvbSBcIm9zXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgT3V0cHV0Q2hhbm5lbERyaXZlcl9DbGlwYm9hcmQgZXh0ZW5kcyBPdXRwdXRDaGFubmVsRHJpdmVyIHtcclxuICAgIHByb3RlY3RlZCByZWFkb25seSB0aXRsZSA9IFwiQ2xpcGJvYXJkXCI7XHJcblxyXG4gICAgcHVibGljIGhhbmRsZShvdXRwdXQ6IE91dHB1dFN0cmVhbXMpIHtcclxuICAgICAgICAvLyBUaGVyZSBjYW4gYmUgYm90aCBcInN0ZG91dFwiIGFuZCBcInN0ZGVyclwiIHByZXNlbnQgYXQgdGhlIHNhbWUgdGltZSwgb3IganVzdCBvbmUgb2YgdGhlbS4gSWYgYm90aCBhcmUgcHJlc2VudCwgdGhleVxyXG4gICAgICAgIC8vIHdpbGwgYmUgam9pbmVkIHRvZ2V0aGVyIHdpdGggXCIgXCIgYXMgYSBzZXBhcmF0b3IuXHJcbiAgICAgICAgbGV0IG91dHB1dF9tZXNzYWdlID0gam9pbk9iamVjdFByb3BlcnRpZXMob3V0cHV0LCBcIiBcIik7XHJcbiAgICAgICAgY2xpcGJvYXJkLndyaXRlVGV4dChvdXRwdXRfbWVzc2FnZSk7XHJcblxyXG4gICAgICAgIC8vIE5vdGlmeSB0aGUgdXNlciBzbyB0aGV5IGtub3cgYSkgd2hhdCB3YXMgY29waWVkIHRvIGNsaXBib2FyZCwgYW5kIGIpIHRoYXQgdGhlaXIgY29tbWFuZCBoYXMgZmluaXNoZWQgZXhlY3V0aW9uLlxyXG4gICAgICAgIHRoaXMucGx1Z2luLm5ld05vdGlmaWNhdGlvbihcIkNvcGllZCB0byBjbGlwYm9hcmQ6IFwiICsgRU9MICsgb3V0cHV0X21lc3NhZ2UpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHtTaGVsbENvbW1hbmRDb25maWd1cmF0aW9ufSBmcm9tIFwiLi4vc2V0dGluZ3MvU2hlbGxDb21tYW5kQ29uZmlndXJhdGlvblwiO1xyXG5pbXBvcnQgU2hlbGxDb21tYW5kc1BsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xyXG5pbXBvcnQge091dHB1dENoYW5uZWxEcml2ZXJfTm90aWZpY2F0aW9ufSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsRHJpdmVyX05vdGlmaWNhdGlvblwiO1xyXG5pbXBvcnQge091dHB1dENoYW5uZWxEcml2ZXJ9IGZyb20gXCIuL091dHB1dENoYW5uZWxEcml2ZXJcIjtcclxuaW1wb3J0IHtPdXRwdXRDaGFubmVsRHJpdmVyX0N1cnJlbnRGaWxlQ2FyZXR9IGZyb20gXCIuL091dHB1dENoYW5uZWxEcml2ZXJfQ3VycmVudEZpbGVDYXJldFwiO1xyXG5pbXBvcnQge091dHB1dENoYW5uZWxEcml2ZXJfQ3VycmVudEZpbGVUb3B9IGZyb20gXCIuL091dHB1dENoYW5uZWxEcml2ZXJfQ3VycmVudEZpbGVUb3BcIjtcclxuaW1wb3J0IHtPdXRwdXRDaGFubmVsLCBPdXRwdXRTdHJlYW19IGZyb20gXCIuL091dHB1dENoYW5uZWxcIjtcclxuaW1wb3J0IHtPdXRwdXRDaGFubmVsRHJpdmVyX1N0YXR1c0Jhcn0gZnJvbSBcIi4vT3V0cHV0Q2hhbm5lbERyaXZlcl9TdGF0dXNCYXJcIjtcclxuaW1wb3J0IHtPdXRwdXRDaGFubmVsRHJpdmVyX0N1cnJlbnRGaWxlQm90dG9tfSBmcm9tIFwiLi9PdXRwdXRDaGFubmVsRHJpdmVyX0N1cnJlbnRGaWxlQm90dG9tXCI7XHJcbmltcG9ydCB7T3V0cHV0Q2hhbm5lbERyaXZlcl9DbGlwYm9hcmR9IGZyb20gXCIuL091dHB1dENoYW5uZWxEcml2ZXJfQ2xpcGJvYXJkXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE91dHB1dFN0cmVhbXMge1xyXG4gICAgc3Rkb3V0Pzogc3RyaW5nO1xyXG4gICAgc3RkZXJyPzogc3RyaW5nO1xyXG59XHJcblxyXG5sZXQgb3V0cHV0X2NoYW5uZWxfZHJpdmVyczp7XHJcbiAgICBba2V5OiBzdHJpbmddOiBPdXRwdXRDaGFubmVsRHJpdmVyO1xyXG59ID0ge307XHJcblxyXG4vLyBSZWdpc3RlciBvdXRwdXQgY2hhbm5lbCBkcml2ZXJzXHJcbnJlZ2lzdGVyT3V0cHV0Q2hhbm5lbERyaXZlcihcInN0YXR1cy1iYXJcIiwgbmV3IE91dHB1dENoYW5uZWxEcml2ZXJfU3RhdHVzQmFyKCkpO1xyXG5yZWdpc3Rlck91dHB1dENoYW5uZWxEcml2ZXIoXCJub3RpZmljYXRpb25cIiwgbmV3IE91dHB1dENoYW5uZWxEcml2ZXJfTm90aWZpY2F0aW9uKCkpO1xyXG5yZWdpc3Rlck91dHB1dENoYW5uZWxEcml2ZXIoXCJjdXJyZW50LWZpbGUtY2FyZXRcIiwgbmV3IE91dHB1dENoYW5uZWxEcml2ZXJfQ3VycmVudEZpbGVDYXJldCgpKTtcclxucmVnaXN0ZXJPdXRwdXRDaGFubmVsRHJpdmVyKFwiY3VycmVudC1maWxlLXRvcFwiLCBuZXcgT3V0cHV0Q2hhbm5lbERyaXZlcl9DdXJyZW50RmlsZVRvcCgpKTtcclxucmVnaXN0ZXJPdXRwdXRDaGFubmVsRHJpdmVyKFwiY3VycmVudC1maWxlLWJvdHRvbVwiLCBuZXcgT3V0cHV0Q2hhbm5lbERyaXZlcl9DdXJyZW50RmlsZUJvdHRvbSgpKTtcclxucmVnaXN0ZXJPdXRwdXRDaGFubmVsRHJpdmVyKFwiY2xpcGJvYXJkXCIsIG5ldyBPdXRwdXRDaGFubmVsRHJpdmVyX0NsaXBib2FyZCgpKTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVTaGVsbENvbW1hbmRPdXRwdXQocGx1Z2luOiBTaGVsbENvbW1hbmRzUGx1Z2luLCBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb246IFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb24sIHN0ZG91dDogc3RyaW5nLCBzdGRlcnI6IHN0cmluZywgZXJyb3JfY29kZTogbnVtYmVyfG51bGwpIHtcclxuICAgIC8vIFRlcm1pbm9sb2d5OiBTdHJlYW0gPSBvdXRwdXRzIHN0cmVhbSBmcm9tIGEgY29tbWFuZCwgY2FuIGJlIFwic3Rkb3V0XCIgb3IgXCJzdGRlcnJcIi4gQ2hhbm5lbCA9IGEgbWV0aG9kIGZvciB0aGlzIGFwcGxpY2F0aW9uIHRvIHByZXNlbnQgdGhlIG91dHB1dCBvdCB1c2VyLCBlLmcuIFwibm90aWZpY2F0aW9uXCIuXHJcblxyXG4gICAgLy8gSW5zZXJ0IHN0ZG91dCBhbmQgc3RkZXJyIHRvIGFuIG9iamVjdCBpbiBhIGNvcnJlY3Qgb3JkZXJcclxuICAgIGxldCBvdXRwdXQ6IE91dHB1dFN0cmVhbXMgPSB7fTtcclxuICAgIGlmIChzdGRvdXQubGVuZ3RoICYmIHN0ZGVyci5sZW5ndGgpIHtcclxuICAgICAgICAvLyBCb3RoIHN0ZG91dCBhbmQgc3RkZXJyIGhhdmUgY29udGVudFxyXG4gICAgICAgIC8vIERlY2lkZSB0aGUgb3V0cHV0IG9yZGVyID09IEZpbmQgb3V0IHdoaWNoIGRhdGEgc3RyZWFtIHNob3VsZCBiZSBwcm9jZXNzZWQgZmlyc3QsIHN0ZG91dCBvciBzdGRlcnIuXHJcbiAgICAgICAgc3dpdGNoIChzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24ub3V0cHV0X2NoYW5uZWxfb3JkZXIpIHtcclxuICAgICAgICAgICAgY2FzZSBcInN0ZG91dC1maXJzdFwiOlxyXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ZG91dDogc3Rkb3V0LFxyXG4gICAgICAgICAgICAgICAgICAgIHN0ZGVycjogc3RkZXJyLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwic3RkZXJyLWZpcnN0XCI6XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RkZXJyOiBzdGRlcnIsXHJcbiAgICAgICAgICAgICAgICAgICAgc3Rkb3V0OiBzdGRvdXQsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChzdGRvdXQubGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gT25seSBzdGRvdXQgaGFzIGNvbnRlbnRcclxuICAgICAgICBvdXRwdXQgPSB7XHJcbiAgICAgICAgICAgIHN0ZG91dDogc3Rkb3V0LFxyXG4gICAgICAgIH07XHJcbiAgICB9IGVsc2UgaWYgKHN0ZGVyci5sZW5ndGgpIHtcclxuICAgICAgICAvLyBPbmx5IHN0ZGVyciBoYXMgY29udGVudFxyXG4gICAgICAgIG91dHB1dCA9IHtcclxuICAgICAgICAgICAgc3RkZXJyOiBzdGRlcnIsXHJcbiAgICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gTmVpdGhlciBzdGRvdXQgbm9yIHN0ZGVyciBoYXZlIGNvbnRlbnRcclxuICAgICAgICAvLyBEbyBub3RoaW5nXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNob3VsZCBzdGRlcnIgYmUgcHJvY2Vzc2VkIHNhbWUgdGltZSB3aXRoIHN0ZG91dD9cclxuICAgIGlmIChzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24ub3V0cHV0X2NoYW5uZWxzLnN0ZG91dCA9PT0gc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLm91dHB1dF9jaGFubmVscy5zdGRlcnIpIHtcclxuICAgICAgICAvLyBTdGRvdXQgYW5kIHN0ZGVyciB1c2UgdGhlIHNhbWUgY2hhbm5lbC5cclxuICAgICAgICAvLyBNYWtlIG9uZSBoYW5kbGluZyBjYWxsLlxyXG4gICAgICAgIGhhbmRsZV9zdHJlYW0oXHJcbiAgICAgICAgICAgIHBsdWdpbixcclxuICAgICAgICAgICAgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLFxyXG4gICAgICAgICAgICBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24ub3V0cHV0X2NoYW5uZWxzLnN0ZG91dCxcclxuICAgICAgICAgICAgb3V0cHV0LFxyXG4gICAgICAgICAgICBlcnJvcl9jb2RlLFxyXG4gICAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFN0ZG91dCBhbmQgc3RkZXJyIHVzZSBkaWZmZXJlbnQgY2hhbm5lbHMuXHJcbiAgICAgICAgLy8gTWFrZSB0d28gaGFuZGxpbmcgY2FsbHMuXHJcbiAgICAgICAgbGV0IG91dHB1dF9zdHJlYW1fbmFtZTogT3V0cHV0U3RyZWFtO1xyXG4gICAgICAgIGZvciAob3V0cHV0X3N0cmVhbV9uYW1lIGluIG91dHB1dCkge1xyXG4gICAgICAgICAgICBsZXQgb3V0cHV0X2NoYW5uZWxfbmFtZSA9IHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5vdXRwdXRfY2hhbm5lbHNbb3V0cHV0X3N0cmVhbV9uYW1lXTtcclxuICAgICAgICAgICAgbGV0IG91dHB1dF9tZXNzYWdlID0gb3V0cHV0W291dHB1dF9zdHJlYW1fbmFtZV07XHJcbiAgICAgICAgICAgIGxldCBzZXBhcmF0ZWRfb3V0cHV0OiBPdXRwdXRTdHJlYW1zID0ge307XHJcbiAgICAgICAgICAgIHNlcGFyYXRlZF9vdXRwdXRbb3V0cHV0X3N0cmVhbV9uYW1lXSA9IG91dHB1dF9tZXNzYWdlO1xyXG4gICAgICAgICAgICBoYW5kbGVfc3RyZWFtKFxyXG4gICAgICAgICAgICAgICAgcGx1Z2luLFxyXG4gICAgICAgICAgICAgICAgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgb3V0cHV0X2NoYW5uZWxfbmFtZSxcclxuICAgICAgICAgICAgICAgIHNlcGFyYXRlZF9vdXRwdXQsXHJcbiAgICAgICAgICAgICAgICBlcnJvcl9jb2RlLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZV9zdHJlYW0oXHJcbiAgICAgICAgcGx1Z2luOiBTaGVsbENvbW1hbmRzUGx1Z2luLFxyXG4gICAgICAgIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbjogU2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbixcclxuICAgICAgICBvdXRwdXRfY2hhbm5lbF9uYW1lOiBPdXRwdXRDaGFubmVsLFxyXG4gICAgICAgIG91dHB1dDogT3V0cHV0U3RyZWFtcyxcclxuICAgICAgICBlcnJvcl9jb2RlOiBudW1iZXJ8bnVsbFxyXG4gICAgKSB7XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgdGhlIG91dHB1dCBzaG91bGQgYmUgaWdub3JlZFxyXG4gICAgaWYgKFwiaWdub3JlXCIgIT09IG91dHB1dF9jaGFubmVsX25hbWUpIHtcclxuICAgICAgICAvLyBUaGUgb3V0cHV0IHNob3VsZCBub3QgYmUgaWdub3JlZC5cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBhbiBvdXRwdXQgZHJpdmVyIGV4aXN0c1xyXG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IG91dHB1dF9jaGFubmVsX2RyaXZlcnNbb3V0cHV0X2NoYW5uZWxfbmFtZV0pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gb3V0cHV0IGRyaXZlciBmb3VuZCBmb3IgY2hhbm5lbCAnXCIgKyBvdXRwdXRfY2hhbm5lbF9uYW1lICsgXCInLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRyaXZlcjogT3V0cHV0Q2hhbm5lbERyaXZlciA9IG91dHB1dF9jaGFubmVsX2RyaXZlcnNbb3V0cHV0X2NoYW5uZWxfbmFtZV07XHJcblxyXG4gICAgICAgIC8vIFBlcmZvcm0gaGFuZGxpbmcgdGhlIG91dHB1dFxyXG4gICAgICAgIGRyaXZlci5pbml0aWFsaXplKHBsdWdpbik7XHJcbiAgICAgICAgZHJpdmVyLmhhbmRsZShvdXRwdXQsIGVycm9yX2NvZGUpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3V0cHV0Q2hhbm5lbERyaXZlcnNPcHRpb25MaXN0KG91dHB1dF9zdHJlYW06IE91dHB1dFN0cmVhbSkge1xyXG4gICAgbGV0IGxpc3Q6IHtcclxuICAgICAgICBba2V5OiBzdHJpbmddOiBzdHJpbmc7XHJcbiAgICB9ID0ge2lnbm9yZTogXCJJZ25vcmVcIn07XHJcbiAgICBmb3IgKGxldCBuYW1lIGluIG91dHB1dF9jaGFubmVsX2RyaXZlcnMpIHtcclxuICAgICAgICBsaXN0W25hbWVdID0gb3V0cHV0X2NoYW5uZWxfZHJpdmVyc1tuYW1lXS5nZXRUaXRsZShvdXRwdXRfc3RyZWFtKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsaXN0O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWdpc3Rlck91dHB1dENoYW5uZWxEcml2ZXIobmFtZTogT3V0cHV0Q2hhbm5lbCwgZHJpdmVyOiBPdXRwdXRDaGFubmVsRHJpdmVyKSB7XHJcbiAgICBpZiAodW5kZWZpbmVkICE9PSBvdXRwdXRfY2hhbm5lbF9kcml2ZXJzW25hbWVdKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3V0cHV0Q2hhbm5lbERyaXZlciBuYW1lZCAnXCIgKyBuYW1lICsgXCInIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCFcIik7XHJcbiAgICB9XHJcbiAgICBvdXRwdXRfY2hhbm5lbF9kcml2ZXJzW25hbWVdID0gZHJpdmVyO1xyXG59IiwiaW1wb3J0IHtBcHAsIE1vZGFsLCBOb3RpY2UsIFNldHRpbmd9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgU2hlbGxDb21tYW5kc1BsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xyXG5pbXBvcnQge1NoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb259IGZyb20gXCIuL1NoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb25cIjtcclxuaW1wb3J0IHtTaGVsbENvbW1hbmRTZXR0aW5nR3JvdXAsIFNoZWxsQ29tbWFuZHNTZXR0aW5nc1RhYn0gZnJvbSBcIi4vU2hlbGxDb21tYW5kc1NldHRpbmdzVGFiXCI7XHJcbmltcG9ydCB7Z2V0T3V0cHV0Q2hhbm5lbERyaXZlcnNPcHRpb25MaXN0fSBmcm9tIFwiLi4vb3V0cHV0X2NoYW5uZWxzL091dHB1dENoYW5uZWxEcml2ZXJGdW5jdGlvbnNcIjtcclxuaW1wb3J0IHtPdXRwdXRDaGFubmVsLCBPdXRwdXRDaGFubmVsT3JkZXIsIE91dHB1dFN0cmVhbX0gZnJvbSBcIi4uL291dHB1dF9jaGFubmVscy9PdXRwdXRDaGFubmVsXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgU2hlbGxDb21tYW5kRXh0cmFPcHRpb25zTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XHJcbiAgICBzdGF0aWMgT1BUSU9OU19TVU1NQVJZID0gXCJBbGlhcywgT3V0cHV0LCBDb25maXJtYXRpb24sIElnbm9yZSBlcnJvcnNcIjtcclxuXHJcbiAgICBwcml2YXRlIHBsdWdpbjogU2hlbGxDb21tYW5kc1BsdWdpbjtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2hlbGxfY29tbWFuZF9pZDogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb246IFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb247XHJcbiAgICBwcml2YXRlIG5hbWVfc2V0dGluZzogU2V0dGluZztcclxuICAgIHByaXZhdGUgc2V0dGluZ190YWI6IFNoZWxsQ29tbWFuZHNTZXR0aW5nc1RhYjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBTaGVsbENvbW1hbmRzUGx1Z2luLCBzaGVsbF9jb21tYW5kX2lkOiBzdHJpbmcsIHNldHRpbmdfZ3JvdXA6IFNoZWxsQ29tbWFuZFNldHRpbmdHcm91cCwgc2V0dGluZ190YWI6IFNoZWxsQ29tbWFuZHNTZXR0aW5nc1RhYikge1xyXG4gICAgICAgIHN1cGVyKGFwcCk7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICAgICAgdGhpcy5zaGVsbF9jb21tYW5kX2lkID0gc2hlbGxfY29tbWFuZF9pZDtcclxuICAgICAgICB0aGlzLnNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbiA9IHBsdWdpbi5nZXRTaGVsbENvbW1hbmRzKClbc2hlbGxfY29tbWFuZF9pZF07XHJcbiAgICAgICAgdGhpcy5uYW1lX3NldHRpbmcgPSBzZXR0aW5nX2dyb3VwLm5hbWVfc2V0dGluZztcclxuICAgICAgICB0aGlzLnNldHRpbmdfdGFiID0gc2V0dGluZ190YWI7XHJcbiAgICB9XHJcblxyXG4gICAgb25PcGVuKCkge1xyXG4gICAgICAgIHRoaXMubW9kYWxFbC5jcmVhdGVFbChcImgyXCIsIHt0ZXh0OiB0aGlzLnNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5zaGVsbF9jb21tYW5kfSk7XHJcblxyXG4gICAgICAgIC8vIEFsaWFzIGZpZWxkXHJcbiAgICAgICAgbmV3IFNldHRpbmcodGhpcy5tb2RhbEVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZShcIkFsaWFzXCIpXHJcbiAgICAgICAgICAgIC5zZXRDbGFzcyhcInNoZWxsLWNvbW1hbmRzLW5hbWUtc2V0dGluZ1wiKVxyXG4gICAgICAgIDtcclxuICAgICAgICBsZXQgYWxpYXNfc2V0dGluZyA9IG5ldyBTZXR0aW5nKHRoaXMubW9kYWxFbClcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5zaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24uYWxpYXMpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlIHRoZSBhY3R1YWwgYWxpYXMgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5hbGlhcyA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgT2JzaWRpYW4gY29tbWFuZCBwYWxldHRlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4ub2JzaWRpYW5fY29tbWFuZHNbdGhpcy5zaGVsbF9jb21tYW5kX2lkXS5uYW1lID0gdGhpcy5wbHVnaW4uZ2VuZXJhdGVPYnNpZGlhbkNvbW1hbmROYW1lKHRoaXMuc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlU2hlbGwgY29tbWFuZHMgc2V0dGluZ3MgcGFuZWxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWVfc2V0dGluZy5zZXROYW1lKHRoaXMuc2V0dGluZ190YWIuZ2VuZXJhdGVDb21tYW5kRmllbGROYW1lKHRoaXMuc2hlbGxfY29tbWFuZF9pZCwgdGhpcy5zaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24pKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZVxyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAuc2V0Q2xhc3MoXCJzaGVsbC1jb21tYW5kcy1zaGVsbC1jb21tYW5kLXNldHRpbmdcIilcclxuICAgICAgICA7XHJcbiAgICAgICAgYWxpYXNfc2V0dGluZy5jb250cm9sRWwuZmluZChcImlucHV0XCIpLmZvY3VzKCk7IC8vIEZvY3VzIHdpdGhvdXQgYSBuZWVkIHRvIGNsaWNrIHRoZSBmaWVsZC5cclxuICAgICAgICB0aGlzLm1vZGFsRWwuY3JlYXRlRWwoXCJwXCIsIHt0ZXh0OiBcIklmIG5vdCBlbXB0eSwgdGhlIGFsaWFzIHdpbGwgYmUgZGlzcGxheWVkIGluIHRoZSBjb21tYW5kIHBhbGV0dGUgaW5zdGVhZCBvZiB0aGUgYWN0dWFsIGNvbW1hbmQuIEFuIGFsaWFzIGlzIG5ldmVyIGV4ZWN1dGVkIGFzIGEgY29tbWFuZC5cIn0pO1xyXG4gICAgICAgIHRoaXMubW9kYWxFbC5jcmVhdGVFbChcInBcIiwge3RleHQ6IFwiWW91IGNhbiBhbHNvIHVzZSB0aGUgc2FtZSB7e319IHN0eWxlIHZhcmlhYmxlcyBpbiBhbGlhc2VzIHRoYXQgYXJlIHVzZWQgaW4gc2hlbGwgY29tbWFuZHMuIFdoZW4gdmFyaWFibGVzIGFyZSB1c2VkIGluIGFsaWFzZXMsIHRoZXkgZG8gbm90IGFmZmVjdCB0aGUgY29tbWFuZCBleGVjdXRpb24gaW4gYW55IHdheSwgYnV0IGl0J3MgYSBuaWNlIHdheSB0byByZXZlYWwgd2hhdCB2YWx1ZXMgeW91ciBjb21tYW5kIHdpbGwgdXNlLCBldmVuIHdoZW4gYW4gYWxpYXMgaGlkZXMgbW9zdCBvZiB0aGUgb3RoZXIgdGVjaG5pY2FsIGRldGFpbHMuXCJ9KTtcclxuXHJcbiAgICAgICAgLy8gQ29uZmlybSBleGVjdXRpb24gZmllbGRcclxuICAgICAgICBuZXcgU2V0dGluZyh0aGlzLm1vZGFsRWwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKFwiQXNrIGNvbmZpcm1hdGlvbiBiZWZvcmUgZXhlY3V0aW9uXCIpXHJcbiAgICAgICAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMuc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLmNvbmZpcm1fZXhlY3V0aW9uKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLmNvbmZpcm1fZXhlY3V0aW9uID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGljb25fY29udGFpbmVyID0gdGhpcy5uYW1lX3NldHRpbmcubmFtZUVsLmZpbmQoXCJzcGFuLnNoZWxsLWNvbW1hbmRzLWNvbmZpcm0tZXhlY3V0aW9uLWljb24tY29udGFpbmVyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5jb25maXJtX2V4ZWN1dGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG93IGljb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbl9jb250YWluZXIucmVtb3ZlQ2xhc3MoXCJzaGVsbC1jb21tYW5kcy1oaWRlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhpZGUgaWNvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uX2NvbnRhaW5lci5hZGRDbGFzcyhcInNoZWxsLWNvbW1hbmRzLWhpZGVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIDtcclxuXHJcbiAgICAgICAgLy8gT3V0cHV0IGNoYW5uZWxpbmdcclxuICAgICAgICB0aGlzLm5ld091dHB1dENoYW5uZWxTZXR0aW5nKFwiT3V0cHV0IGNoYW5uZWwgZm9yIHN0ZG91dFwiLCBcInN0ZG91dFwiKTtcclxuICAgICAgICB0aGlzLm5ld091dHB1dENoYW5uZWxTZXR0aW5nKFwiT3V0cHV0IGNoYW5uZWwgZm9yIHN0ZGVyclwiLCBcInN0ZGVyclwiLCBcIklmIGJvdGggc3Rkb3V0IGFuZCBzdGRlcnIgdXNlIHRoZSBzYW1lIGNoYW5uZWwsIHN0ZGVyciB3aWxsIGJlIGNvbWJpbmVkIHRvIHNhbWUgbWVzc2FnZSB3aXRoIHN0ZG91dC5cIik7XHJcbiAgICAgICAgbmV3IFNldHRpbmcodGhpcy5tb2RhbEVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZShcIk9yZGVyIG9mIHN0ZG91dC9zdGRlcnIgb3V0cHV0XCIpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKFwiV2hlbiBvdXRwdXQgY29udGFpbnMgYm90aCBlcnJvcnMgYW5kIG5vcm1hbCBvdXRwdXQsIHdoaWNoIG9uZSBzaG91bGQgYmUgcHJlc2VudGVkIGZpcnN0P1wiKVxyXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4gZHJvcGRvd25cclxuICAgICAgICAgICAgICAgIC5hZGRPcHRpb25zKHtcclxuICAgICAgICAgICAgICAgICAgICBcInN0ZG91dC1maXJzdFwiOiBcIlN0ZG91dCBmaXJzdCwgdGhlbiBzdGRlcnIuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJzdGRlcnItZmlyc3RcIjogXCJTdGRlcnIgZmlyc3QsIHRoZW4gc3Rkb3V0LlwiLFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5vdXRwdXRfY2hhbm5lbF9vcmRlcilcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWU6IE91dHB1dENoYW5uZWxPcmRlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLm91dHB1dF9jaGFubmVsX29yZGVyID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgO1xyXG5cclxuICAgICAgICAvLyBJZ25vcmUgZXJyb3JzIGZpZWxkXHJcbiAgICAgICAgbmV3IFNldHRpbmcodGhpcy5tb2RhbEVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZShcIklnbm9yZSBlcnJvciBjb2Rlc1wiKVxyXG4gICAgICAgICAgICAuc2V0RGVzYyhcIkEgY29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgbnVtYmVycy4gSWYgZXhlY3V0aW5nIGEgc2hlbGwgY29tbWFuZCBmYWlscyB3aXRoIG9uZSBvZiB0aGVzZSBleGl0IGNvZGVzLCBubyBlcnJvciBtZXNzYWdlIHdpbGwgYmUgZGlzcGxheWVkLCBhbmQgdGhlIGFib3ZlIHN0ZGVyciBjaGFubmVsIHdpbGwgYmUgaWdub3JlZC4gU3Rkb3V0IGNoYW5uZWwgd2lsbCBzdGlsbCBiZSB1c2VkIGZvciBzdGRvdXQuIEVycm9yIGNvZGVzIG11c3QgYmUgaW50ZWdlcnMgYW5kIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLiBBbnl0aGluZyBlbHNlIHdpbGwgYmUgcmVtb3ZlZC5cIilcclxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5zaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24uaWdub3JlX2Vycm9yX2NvZGVzLmpvaW4oXCIsXCIpKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBzdHJpbmcgb2YgY29tbWEgc2VwYXJhdGVkIG51bWJlcnNcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaWdub3JlX2Vycm9yX2NvZGVzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByYXdfZXJyb3JfY29kZXMgPSB2YWx1ZS5zcGxpdChcIixcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSBpbiByYXdfZXJyb3JfY29kZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJhd19lcnJvcl9jb2RlID0gcmF3X2Vycm9yX2NvZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXJyb3JfY29kZV9jYW5kaWRhdGUgPSBwYXJzZUludChyYXdfZXJyb3JfY29kZS50cmltKCkpOyAvLyBFLmcuIGFuIGVtcHR5IHN0cmluZyBjb252ZXJ0cyB0byBOYU4gKD0gTm90IGEgTnVtYmVyKS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGVycm9yIGNvZGUgaXMgbm90IE5hTiwgMCBvciBhIG5lZ2F0aXZlIG51bWJlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihlcnJvcl9jb2RlX2NhbmRpZGF0ZSkgJiYgZXJyb3JfY29kZV9jYW5kaWRhdGUgPj0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNhbmRpZGF0ZSBpcyBsZWdpdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZV9lcnJvcl9jb2Rlcy5wdXNoKGVycm9yX2NvZGVfY2FuZGlkYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgdmFsaWRhdGVkIGVycm9yIG51bWJlcnNcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5pZ25vcmVfZXJyb3JfY29kZXMgPSBpZ25vcmVfZXJyb3JfY29kZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBpY29uXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGljb25fY29udGFpbmVyID0gdGhpcy5uYW1lX3NldHRpbmcubmFtZUVsLmZpbmQoXCJzcGFuLnNoZWxsLWNvbW1hbmRzLWlnbm9yZWQtZXJyb3ItY29kZXMtaWNvbi1jb250YWluZXJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLmlnbm9yZV9lcnJvcl9jb2Rlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyBpY29uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25fY29udGFpbmVyLnNldEF0dHIoXCJhcmlhLWxhYmVsXCIsIHRoaXMuc2V0dGluZ190YWIuZ2VuZXJhdGVJZ25vcmVkRXJyb3JDb2Rlc0ljb25UaXRsZSh0aGlzLnNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5pZ25vcmVfZXJyb3JfY29kZXMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbl9jb250YWluZXIucmVtb3ZlQ2xhc3MoXCJzaGVsbC1jb21tYW5kcy1oaWRlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhpZGUgaWNvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uX2NvbnRhaW5lci5hZGRDbGFzcyhcInNoZWxsLWNvbW1hbmRzLWhpZGVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG5ld091dHB1dENoYW5uZWxTZXR0aW5nKHRpdGxlOiBzdHJpbmcsIG91dHB1dF9zdHJlYW1fbmFtZTogT3V0cHV0U3RyZWFtLCBkZXNjcmlwdGlvbjogc3RyaW5nID0gXCJcIikge1xyXG4gICAgICAgIGxldCBvdXRwdXRfY2hhbm5lbF9vcHRpb25zID0gZ2V0T3V0cHV0Q2hhbm5lbERyaXZlcnNPcHRpb25MaXN0KG91dHB1dF9zdHJlYW1fbmFtZSk7XHJcbiAgICAgICAgbmV3IFNldHRpbmcodGhpcy5tb2RhbEVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSh0aXRsZSlcclxuICAgICAgICAgICAgLnNldERlc2MoZGVzY3JpcHRpb24pXHJcbiAgICAgICAgICAgIC5hZGREcm9wZG93bihkcm9wZG93biA9PiBkcm9wZG93blxyXG4gICAgICAgICAgICAgICAgLmFkZE9wdGlvbnMob3V0cHV0X2NoYW5uZWxfb3B0aW9ucylcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5vdXRwdXRfY2hhbm5lbHNbb3V0cHV0X3N0cmVhbV9uYW1lXSlcclxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWU6IE91dHB1dENoYW5uZWwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5vdXRwdXRfY2hhbm5lbHNbb3V0cHV0X3N0cmVhbV9uYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIDtcclxuICAgIH1cclxufSIsImltcG9ydCB7TW9kYWwsIFNldHRpbmd9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgU2hlbGxDb21tYW5kc1BsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xyXG5pbXBvcnQge1NoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb259IGZyb20gXCIuL1NoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb25cIjtcclxuaW1wb3J0IHtTaGVsbENvbW1hbmRTZXR0aW5nR3JvdXB9IGZyb20gXCIuL1NoZWxsQ29tbWFuZHNTZXR0aW5nc1RhYlwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFNoZWxsQ29tbWFuZERlbGV0ZU1vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG4gICAgcHJpdmF0ZSBwbHVnaW46IFNoZWxsQ29tbWFuZHNQbHVnaW47XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNoZWxsX2NvbW1hbmRfaWQ6IHN0cmluZztcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uOiBTaGVsbENvbW1hbmRDb25maWd1cmF0aW9uO1xyXG4gICAgcHJpdmF0ZSBzZXR0aW5nX2dyb3VwOiBTaGVsbENvbW1hbmRTZXR0aW5nR3JvdXA7XHJcbiAgICBwcml2YXRlIGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwbHVnaW46IFNoZWxsQ29tbWFuZHNQbHVnaW4sIHNoZWxsX2NvbW1hbmRfaWQ6IHN0cmluZywgc2V0dGluZ19ncm91cDogU2hlbGxDb21tYW5kU2V0dGluZ0dyb3VwLCBjb250YWluZXJfZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICBzdXBlcihwbHVnaW4uYXBwKTtcclxuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICAgICAgICB0aGlzLnNoZWxsX2NvbW1hbmRfaWQgPSBzaGVsbF9jb21tYW5kX2lkO1xyXG4gICAgICAgIHRoaXMuc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uID0gcGx1Z2luLmdldFNoZWxsQ29tbWFuZHMoKVtzaGVsbF9jb21tYW5kX2lkXTtcclxuICAgICAgICB0aGlzLnNldHRpbmdfZ3JvdXAgPSBzZXR0aW5nX2dyb3VwO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyX2VsZW1lbnQgPSBjb250YWluZXJfZWxlbWVudDtcclxuICAgIH1cclxuXHJcbiAgICBvbk9wZW4oKSB7XHJcbiAgICAgICAgdGhpcy5tb2RhbEVsLmNyZWF0ZUVsKFwiaDJcIiwge3RleHQ6IFwiRGVsZXRlOiBcIiArIHRoaXMuc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLnNoZWxsX2NvbW1hbmR9KTtcclxuICAgICAgICBpZiAodGhpcy5zaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24uYWxpYXMpIHtcclxuICAgICAgICAgICAgdGhpcy5tb2RhbEVsLmNyZWF0ZUVsKFwicFwiLCB7dGV4dDogXCJBbGlhczogXCIgKyB0aGlzLnNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5hbGlhc30pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1vZGFsRWwuY3JlYXRlRWwoXCJwXCIsIHt0ZXh0OiBcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGUgdGhpcyBzaGVsbCBjb21tYW5kP1wifSk7XHJcbiAgICAgICAgbGV0IGRlbGV0ZV9idXR0b24gPSB0aGlzLm1vZGFsRWwuY3JlYXRlRWwoXCJidXR0b25cIiwge3RleHQ6IFwiWWVzLCBkZWxldGVcIn0pO1xyXG4gICAgICAgIGRlbGV0ZV9idXR0b24ub25jbGljayA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBjb21tYW5kXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29tbWFuZCBcIiArIHRoaXMuc2hlbGxfY29tbWFuZF9pZCArIFwiIGdvbm5hIGJlIHJlbW92ZWQuXCIpO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5wbHVnaW4uZ2V0U2hlbGxDb21tYW5kcygpW3RoaXMuc2hlbGxfY29tbWFuZF9pZF07IC8vIFJlbW92ZSBmcm9tIHRoZSBwbHVnaW4ncyBzZXR0aW5ncy5cclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMucGx1Z2luLm9ic2lkaWFuX2NvbW1hbmRzW3RoaXMuc2hlbGxfY29tbWFuZF9pZF07IC8vIFJlbW92ZSBmcm9tIHRoZSBjb21tYW5kIHBhbGV0dGUuXHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNldHRpbmcgZmllbGRzXHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyX2VsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5zZXR0aW5nX2dyb3VwLm5hbWVfc2V0dGluZy5zZXR0aW5nRWwpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lcl9lbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuc2V0dGluZ19ncm91cC5zaGVsbF9jb21tYW5kX3NldHRpbmcuc2V0dGluZ0VsKTtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXJfZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLnNldHRpbmdfZ3JvdXAucHJldmlld19zZXR0aW5nLnNldHRpbmdFbCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJDb21tYW5kIHJlbW92ZWQuXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbn0iLCJpbXBvcnQge0hvdGtleSwgTW9kaWZpZXIsIFBsYXRmb3JtfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IFNoZWxsQ29tbWFuZHNQbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdGtleXNGb3JTaGVsbENvbW1hbmQocGx1Z2luOiBTaGVsbENvbW1hbmRzUGx1Z2luLCBzaGVsbF9jb21tYW5kX2lkOiBzdHJpbmcpOiBIb3RrZXlbXSB7XHJcbiAgICAvLyBSZXRyaWV2ZSBhbGwgaG90a2V5cyBzZXQgYnkgdXNlci5cclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIGxldCBhcHBfY3VzdG9tX2hvdGtleXMgPSBwbHVnaW4uYXBwLmhvdGtleU1hbmFnZXI/LmN1c3RvbUtleXM7XHJcbiAgICBpZiAoIWFwcF9jdXN0b21faG90a2V5cykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiZ2V0SG90a2V5c0ZvclNoZWxsQ29tbWFuZCgpIGZhaWxlZCwgd2lsbCByZXR1cm4gYW4gZW1wdHkgYXJyYXkuXCIpXHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCBvbmx5IG91ciBob3RrZXlzLlxyXG4gICAgbGV0IGhvdGtleV9pbmRleCA9cGx1Z2luLmdldFBsdWdpbklkKCkgKyBcIjpcIiArIHBsdWdpbi5nZW5lcmF0ZU9ic2lkaWFuQ29tbWFuZElkKHNoZWxsX2NvbW1hbmRfaWQpOyAvLyBFLmcuIFwib2JzaWRpYW4tc2hlbGxjb21tYW5kczpzaGVsbC1jb21tYW5kLTBcIlxyXG4gICAgY29uc29sZS5sb2coXCJnZXRIb3RrZXlzRm9yU2hlbGxDb21tYW5kKCkgc3VjY2VlZGVkLlwiKVxyXG4gICAgcmV0dXJuIGFwcF9jdXN0b21faG90a2V5c1tob3RrZXlfaW5kZXhdID8/IFtdOyAvLyBJZiBubyBob3RrZXkgYXJyYXkgaXMgc2V0IGZvciB0aGlzIGNvbW1hbmQsIHJldHVybiBhbiBlbXB0eSBhcnJheS4gQWx0aG91Z2ggSSBkbyBiZWxpZXZlIHRoYXQgYWxsIGNvbW1hbmRzIGRvIGhhdmUgYW4gYXJyYXkgYW55d2F5LCBidXQgaGF2ZSB0aGlzIGNoZWNrIGp1c3QgaW4gY2FzZS5cclxufVxyXG5cclxuLyoqXHJcbiAqIFRPRE86IElzIHRoZXJlIGEgd2F5IHRvIG1ha2UgT2JzaWRpYW4gZG8gdGhpcyBjb252ZXJzaW9uIGZvciB1cz9cclxuICpcclxuICogQHBhcmFtIGhvdGtleVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBIb3RrZXlUb1N0cmluZyhob3RrZXk6IEhvdGtleSkge1xyXG4gICAgbGV0IGtleXM6IHN0cmluZ1tdID0gW107XHJcbiAgICBob3RrZXkubW9kaWZpZXJzLmZvckVhY2goKG1vZGlmaWVyOiBNb2RpZmllcikgPT4ge1xyXG4gICAgICAgIGxldCBtb2RpZmllcl9rZXkgPSBtb2RpZmllci50b1N0cmluZygpOyAvLyBUaGlzIGlzIG9uZSBvZiAnTW9kJyB8ICdDdHJsJyB8ICdNZXRhJyB8ICdTaGlmdCcgfCAnQWx0J1xyXG4gICAgICAgIGlmIChcIk1vZFwiID09PSBtb2RpZmllcl9rZXkpIHtcclxuICAgICAgICAgICAgLy8gQ2hhbmdlIFwiTW9kXCIgdG8gc29tZXRoaW5nIG1vcmUgbWVhbmluZ2Z1bC5cclxuICAgICAgICAgICAgbW9kaWZpZXJfa2V5ID0gUGxhdGZvcm0uaXNNYWNPUyA/IFwiQ21kXCIgOiBcIkN0cmxcIjsgLy8gaXNNYWNPUyBzaG91bGQgYWxzbyBiZSB0cnVlIGlmIHRoZSBkZXZpY2UgaXMgaVBob25lL2lQYWQuIENhbiBiZSBoYW5keSBpZiB0aGlzIHBsdWdpbiBnZXRzIG1vYmlsZSBzdXBwb3J0IHNvbWUgZGF5LlxyXG4gICAgICAgIH1cclxuICAgICAgICBrZXlzLnB1c2gobW9kaWZpZXJfa2V5KTtcclxuICAgIH0pO1xyXG4gICAga2V5cy5wdXNoKGhvdGtleS5rZXkpOyAvLyBUaGlzIGlzIHNvbWV0aGluZyBsaWtlIGEgbGV0dGVyICgnQScsICdCJyBldGMpIG9yIHNwYWNlL2VudGVyL3doYXRldmVyLlxyXG4gICAgcmV0dXJuIGtleXMuam9pbihcIiArIFwiKTtcclxufSIsImltcG9ydCB7QXBwLCBIb3RrZXksIFBsdWdpblNldHRpbmdUYWIsIHNldEljb24sIFNldHRpbmd9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgU2hlbGxDb21tYW5kc1BsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xyXG5pbXBvcnQge2dldFZhdWx0QWJzb2x1dGVQYXRofSBmcm9tIFwiLi4vQ29tbW9uXCI7XHJcbmltcG9ydCB7bmV3U2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbiwgU2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vU2hlbGxDb21tYW5kQ29uZmlndXJhdGlvblwiO1xyXG5pbXBvcnQge1NoZWxsQ29tbWFuZEV4dHJhT3B0aW9uc01vZGFsfSBmcm9tIFwiLi9TaGVsbENvbW1hbmRFeHRyYU9wdGlvbnNNb2RhbFwiO1xyXG5pbXBvcnQge1NoZWxsQ29tbWFuZERlbGV0ZU1vZGFsfSBmcm9tIFwiLi9TaGVsbENvbW1hbmREZWxldGVNb2RhbFwiO1xyXG5pbXBvcnQge2dldFNoZWxsQ29tbWFuZFZhcmlhYmxlSW5zdHJ1Y3Rpb25zfSBmcm9tIFwiLi4vdmFyaWFibGVzL1NoZWxsQ29tbWFuZFZhcmlhYmxlSW5zdHJ1Y3Rpb25zXCI7XHJcbmltcG9ydCB7cGFyc2VTaGVsbENvbW1hbmRWYXJpYWJsZXN9IGZyb20gXCIuLi92YXJpYWJsZXMvcGFyc2VTaGVsbENvbW1hbmRWYXJpYWJsZXNcIjtcclxuaW1wb3J0IHtnZXRIb3RrZXlzRm9yU2hlbGxDb21tYW5kLCBIb3RrZXlUb1N0cmluZ30gZnJvbSBcIi4uL0hvdGtleXNcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBTaGVsbENvbW1hbmRzU2V0dGluZ3NUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcclxuICAgIHBsdWdpbjogU2hlbGxDb21tYW5kc1BsdWdpbjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBTaGVsbENvbW1hbmRzUGx1Z2luKSB7XHJcbiAgICAgICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xyXG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG4gICAgfVxyXG5cclxuICAgIGRpc3BsYXkoKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IHtjb250YWluZXJFbH0gPSB0aGlzO1xyXG5cclxuICAgICAgICBjb250YWluZXJFbC5lbXB0eSgpO1xyXG5cclxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7dGV4dDogXCJTaGVsbCBjb21tYW5kc1wifSk7XHJcblxyXG4gICAgICAgIC8vIFwiV29ya2luZyBkaXJlY3RvcnlcIiBmaWVsZFxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZShcIldvcmtpbmcgZGlyZWN0b3J5XCIpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKFwiQSBkaXJlY3Rvcnkgd2hlcmUgeW91ciBjb21tYW5kcyB3aWxsIGJlIHJ1bi4gSWYgZW1wdHksIGRlZmF1bHRzIHRvIHlvdXIgdmF1bHQncyBsb2NhdGlvbi4gQ2FuIGJlIHJlbGF0aXZlICg9IGEgZm9sZGVyIGluIHRoZSB2YXVsdCkgb3IgYWJzb2x1dGUgKD0gY29tcGxldGUgZnJvbSBmaWxlc3lzdGVtIHJvb3QpLlwiKVxyXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihnZXRWYXVsdEFic29sdXRlUGF0aCh0aGlzLmFwcCkpXHJcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mud29ya2luZ19kaXJlY3RvcnkpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDaGFuZ2luZyB3b3JraW5nX2RpcmVjdG9yeSB0byBcIiArIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy53b3JraW5nX2RpcmVjdG9yeSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIDtcclxuXHJcbiAgICAgICAgLy8gQSA8ZGl2PiBlbGVtZW50IGZvciBhbGwgY29tbWFuZCBpbnB1dCBmaWVsZHMuIE5ldyBjb21tYW5kIGZpZWxkcyBjYW4gYmUgY3JlYXRlZCBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZWxlbWVudC5cclxuICAgICAgICBsZXQgY29tbWFuZF9maWVsZHNfY29udGFpbmVyID0gY29udGFpbmVyRWwuY3JlYXRlRWwoXCJkaXZcIik7XHJcblxyXG4gICAgICAgIC8vIEZpZWxkcyBmb3IgbW9kaWZ5aW5nIGV4aXN0aW5nIGNvbW1hbmRzXHJcbiAgICAgICAgZm9yIChsZXQgY29tbWFuZF9pZCBpbiB0aGlzLnBsdWdpbi5nZXRTaGVsbENvbW1hbmRzKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVDb21tYW5kRmllbGQoY29tbWFuZF9maWVsZHNfY29udGFpbmVyLCBjb21tYW5kX2lkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFwiTmV3IGNvbW1hbmRcIiBidXR0b25cclxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXHJcbiAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dChcIk5ldyBjb21tYW5kXCIpXHJcbiAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVDb21tYW5kRmllbGQoY29tbWFuZF9maWVsZHNfY29udGFpbmVyLCBcIm5ld1wiKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk5ldyBlbXB0eSBjb21tYW5kIGNyZWF0ZWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIDtcclxuXHJcbiAgICAgICAgLy8gXCJFcnJvciBtZXNzYWdlIGR1cmF0aW9uXCIgZmllbGRcclxuICAgICAgICB0aGlzLmNyZWF0ZU5vdGlmaWNhdGlvbkR1cmF0aW9uRmllbGQoY29udGFpbmVyRWwsIFwiRXJyb3IgbWVzc2FnZSBkdXJhdGlvblwiLCBcIkNvbmNlcm5zIG1lc3NhZ2VzIGFib3V0IGZhaWxlZCBzaGVsbCBjb21tYW5kcy5cIiwgXCJlcnJvcl9tZXNzYWdlX2R1cmF0aW9uXCIpO1xyXG5cclxuICAgICAgICAvLyBcIk5vdGlmaWNhdGlvbiBtZXNzYWdlIGR1cmF0aW9uXCIgZmllbGRcclxuICAgICAgICB0aGlzLmNyZWF0ZU5vdGlmaWNhdGlvbkR1cmF0aW9uRmllbGQoY29udGFpbmVyRWwsIFwiTm90aWZpY2F0aW9uIG1lc3NhZ2UgZHVyYXRpb25cIiwgXCJDb25jZXJucyBpbmZvcm1hdGlvbmFsLCBub24gZmF0YWwgbWVzc2FnZXMsIGUuZy4gb3V0cHV0IGRpcmVjdGVkIHRvICdOb3RpZmljYXRpb24gYmFsbG9vbicuXCIsIFwibm90aWZpY2F0aW9uX21lc3NhZ2VfZHVyYXRpb25cIik7XHJcblxyXG4gICAgICAgIC8vIFwiVmFyaWFibGVzXCIgc2VjdGlvblxyXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaDJcIiwge3RleHQ6IFwiVmFyaWFibGVzXCJ9KTtcclxuXHJcbiAgICAgICAgLy8gXCJQcmV2aWV3IHZhcmlhYmxlcyBpbiBjb21tYW5kIHBhbGV0dGVcIiBmaWVsZFxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZShcIlByZXZpZXcgdmFyaWFibGVzIGluIGNvbW1hbmQgcGFsZXR0ZVwiKVxyXG4gICAgICAgICAgICAuc2V0RGVzYyhcIklmIG9uLCB2YXJpYWJsZSBuYW1lcyBhcmUgc3Vic3RpdHV0ZWQgd2l0aCB0aGVpciByZWFsdGltZSB2YWx1ZXMgd2hlbiB5b3UgdmlldyB5b3VyIGNvbW1hbmRzIGluIHRoZSBjb21tYW5kIHBhbGV0dGUuIEEgbmljZSB3YXkgdG8gZW5zdXJlIHlvdXIgY29tbWFuZHMgd2lsbCB1c2UgY29ycmVjdCB2YWx1ZXMuXCIpXHJcbiAgICAgICAgICAgIC5hZGRUb2dnbGUoY2hlY2tib3ggPT4gY2hlY2tib3hcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcmV2aWV3X3ZhcmlhYmxlc19pbl9jb21tYW5kX3BhbGV0dGUpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBib29sZWFuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDaGFuZ2luZyBwcmV2aWV3X3ZhcmlhYmxlc19pbl9jb21tYW5kX3BhbGV0dGUgdG8gXCIgKyB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucHJldmlld192YXJpYWJsZXNfaW5fY29tbWFuZF9wYWxldHRlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBWYXJpYWJsZSBwcmV2aWV3aW5nIGlzIHR1cm5lZCBmcm9tIG9uIHRvIG9mZi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IHRoZSBjb21tYW5kIHBhbGV0dGUgbWF5IGhhdmUgb2xkLCBzdGFsZSB2YXJpYWJsZSBkYXRhIGluIGl0IChpZiBhIHVzZXIgaGFzIG9wZW5lZCB0aGUgcGFsZXR0ZSwgYnV0IGNsb3NlZCBpdCB3aXRob3V0IGV4ZWN1dGluZyBhbnl0aGluZykuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvbGQsIHByZXBhcnNlZCB2YXJpYWJsZSBkYXRhIGFuZCByZXNldCBzaGVsbCBjb21tYW5kcycgbmFtZXMgaW4gdGhlIGNvbW1hbmQgcGFsZXR0ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4ucmVzZXRQcmVwYXJzZWRTaGVsbENvbW1hbmRDb25maWd1cmF0aW9ucygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5yZXNldENvbW1hbmRQYWxldHRlTmFtZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgO1xyXG5cclxuICAgICAgICAvLyBWYXJpYWJsZSBpbnN0cnVjdGlvbnNcclxuICAgICAgICBnZXRTaGVsbENvbW1hbmRWYXJpYWJsZUluc3RydWN0aW9ucygpLmZvckVhY2goKGluc3RydWN0aW9ucykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcGFyYWdyYXBoID0gY29udGFpbmVyRWwuY3JlYXRlRWwoXCJwXCIpO1xyXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgIHBhcmFncmFwaC5jcmVhdGVFbChcInN0cm9uZ1wiLCB7dGV4dDogaW5zdHJ1Y3Rpb25zLnZhcmlhYmxlX25hbWUgKyBcIiBcIn0pO1xyXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgIHBhcmFncmFwaC5jcmVhdGVFbChcInNwYW5cIiwge3RleHQ6IGluc3RydWN0aW9ucy5pbnN0cnVjdGlvbnN9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbChcInBcIiwge3RleHQ6IFwiV2hlbiB5b3UgdHlwZSB2YXJpYWJsZXMgaW50byBjb21tYW5kcywgYSBwcmV2aWV3IHRleHQgYXBwZWFycyB1bmRlciB0aGUgY29tbWFuZCBmaWVsZCB0byBzaG93IGhvdyB0aGUgY29tbWFuZCB3aWxsIGxvb2sgbGlrZSB3aGVuIGl0IGdldHMgZXhlY3V0ZWQgd2l0aCB2YXJpYWJsZXMgc3Vic3RpdHV0ZWQgd2l0aCB0aGVpciByZWFsIHZhbHVlcy5cIn0pXHJcbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoXCJwXCIsIHt0ZXh0OiBcIlRoZXJlIGlzIG5vIHdheSB0byBlc2NhcGUgdmFyaWFibGUgcGFyc2luZy4gSWYgeW91IG5lZWQge3sgfX0gY2hhcmFjdGVycyBpbiB5b3VyIGNvbW1hbmQsIHRoZXkgd29uJ3QgYmUgcGFyc2VkIGFzIHZhcmlhYmxlcyBhcyBsb25nIGFzIHRoZXkgZG8gbm90IGNvbnRhaW4gYW55IG9mIHRoZSB2YXJpYWJsZSBuYW1lcyBsaXN0ZWQgYmVsb3cuIElmIHlvdSB3b3VsZCBuZWVkIHRvIHBhc3MgZS5nLiB7e3RpdGxlfX0gbGl0ZXJhbGx5IHRvIHlvdXIgY29tbWFuZCwgdGhlcmUgaXMgbm8gd2F5IHRvIGRvIGl0IGF0bSwgcGxlYXNlIHJhaXNlIGFuIGlzc3VlIGluIEdpdEh1Yi5cIn0pXHJcbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoXCJwXCIsIHt0ZXh0OiBcIkFsbCB2YXJpYWJsZXMgdGhhdCBhY2Nlc3MgdGhlIGN1cnJlbnQgZmlsZSwgbWF5IGNhdXNlIHRoZSBjb21tYW5kIHByZXZpZXcgdG8gZmFpbCBpZiB5b3UgaGFkIG5vIGZpbGUgcGFuZWwgYWN0aXZlIHdoZW4geW91IG9wZW5lZCB0aGUgc2V0dGluZ3Mgd2luZG93IC0gZS5nLiB5b3UgaGFkIGZvY3VzIG9uIGdyYXBoIHZpZXcgaW5zdGVhZCBvZiBhIG5vdGUgPSBubyBmaWxlIGlzIGN1cnJlbnRseSBhY3RpdmUuIEJ1dCB0aGlzIGRvZXMgbm90IGJyZWFrIGFueXRoaW5nIGVsc2UgdGhhbiB0aGUgcHJldmlldy5cIn0pXHJcblxyXG5cclxuICAgICAgICAvLyBLRUVQIFRISVMgQUZURVIgQ1JFQVRJTkcgQUxMIEVMRU1FTlRTOlxyXG4gICAgICAgIHRoaXMucmVtZW1iZXJTY3JvbGxQb3NpdGlvbihjb250YWluZXJFbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbnRhaW5lcl9lbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gc2hlbGxfY29tbWFuZF9pZCBFaXRoZXIgYSBzdHJpbmcgZm9ybWF0dGVkIGludGVnZXIgKFwiMFwiLCBcIjFcIiBldGMpIG9yIFwibmV3XCIgaWYgaXQncyBhIGZpZWxkIGZvciBhIGNvbW1hbmQgdGhhdCBkb2VzIG5vdCBleGlzdCB5ZXQuXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZUNvbW1hbmRGaWVsZChjb250YWluZXJfZWxlbWVudDogSFRNTEVsZW1lbnQsIHNoZWxsX2NvbW1hbmRfaWQ6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBpc19uZXcgPSBcIm5ld1wiID09PSBzaGVsbF9jb21tYW5kX2lkO1xyXG4gICAgICAgIGxldCBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb246IFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb247XHJcbiAgICAgICAgaWYgKGlzX25ldykge1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYW4gZW1wdHkgY29tbWFuZFxyXG4gICAgICAgICAgICBzaGVsbF9jb21tYW5kX2lkID0gdGhpcy5wbHVnaW4uZ2VuZXJhdGVOZXdTaGVsbENvbW1hbmRJRCgpO1xyXG4gICAgICAgICAgICBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24gPSBuZXdTaGVsbENvbW1hbmRDb25maWd1cmF0aW9uKCk7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLmdldFNoZWxsQ29tbWFuZHMoKVtzaGVsbF9jb21tYW5kX2lkXSA9IHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbjtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBlbXB0eSBzaGVsbCBjb21tYW5kIHRvIE9ic2lkaWFuJ3MgY29tbWFuZCBwYWxldHRlLlxyXG4gICAgICAgICAgICAvLyBEbyBpdCBhbHJlYWR5IG5vdywgYmVjYXVzZSB0aGVyZSBhcmUgc2V0dGluZ3MgKGUuZy4gQWxpYXMpIHRoYXQsIHdoZW4gY2hhbmdlZCBieSB0aGUgdXNlciwgd2lsbCB0cnkgdG8gbW9kaWZ5IHRoZSBPYnNpZGlhbiBjb21tYW5kLiBTb21ldGltZXMgdXNlcnMgZWRpdCB0aGVzZSBzZXR0aW5ncyBiZWZvcmUgd3JpdGluZyB0aGUgYWN0dWFsIGNvbW1hbmQuIFNlZSBpc3N1ZSAjNDY6IGh0dHBzOi8vZ2l0aHViLmNvbS9UYWl0YXZhL29ic2lkaWFuLXNoZWxsY29tbWFuZHMvaXNzdWVzLzQ2XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnJlZ2lzdGVyU2hlbGxDb21tYW5kKHNoZWxsX2NvbW1hbmRfaWQsIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVXNlIGFuIG9sZCBzaGVsbCBjb21tYW5kXHJcbiAgICAgICAgICAgIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbiA9IHRoaXMucGx1Z2luLmdldFNoZWxsQ29tbWFuZHMoKVtzaGVsbF9jb21tYW5kX2lkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJDcmVhdGUgY29tbWFuZCBmaWVsZCBmb3IgY29tbWFuZCAjXCIgKyBzaGVsbF9jb21tYW5kX2lkICsgKGlzX25ldyA/IFwiIChORVcpXCIgOiBcIlwiKSk7XHJcbiAgICAgICAgbGV0IHNoZWxsX2NvbW1hbmQ6IHN0cmluZztcclxuICAgICAgICBpZiAoaXNfbmV3KSB7XHJcbiAgICAgICAgICAgIHNoZWxsX2NvbW1hbmQgPSBcIlwiO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNoZWxsX2NvbW1hbmQgPSBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24uc2hlbGxfY29tbWFuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHNldHRpbmdfZ3JvdXA6IFNoZWxsQ29tbWFuZFNldHRpbmdHcm91cCA9IHtcclxuICAgICAgICAgICAgbmFtZV9zZXR0aW5nOlxyXG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAuc2V0TmFtZSh0aGlzLmdlbmVyYXRlQ29tbWFuZEZpZWxkTmFtZShzaGVsbF9jb21tYW5kX2lkLCB0aGlzLnBsdWdpbi5nZXRTaGVsbENvbW1hbmRzKClbc2hlbGxfY29tbWFuZF9pZF0pKVxyXG4gICAgICAgICAgICAgICAgLmFkZEV4dHJhQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cclxuICAgICAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcChcIkV4ZWN1dGUgbm93XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldEljb24oXCJydW4tY29tbWFuZFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhlY3V0ZSB0aGUgc2hlbGwgY29tbWFuZCBub3cgKGZvciB0cnlpbmcgaXQgb3V0IGluIHRoZSBzZXR0aW5ncylcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbiA9IHRoaXMucGx1Z2luLmdldFNoZWxsQ29tbWFuZHMoKVtzaGVsbF9jb21tYW5kX2lkXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnNlZF9zaGVsbF9jb21tYW5kID0gcGFyc2VTaGVsbENvbW1hbmRWYXJpYWJsZXModGhpcy5wbHVnaW4sIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5zaGVsbF9jb21tYW5kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkX3NoZWxsX2NvbW1hbmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5uZXdFcnJvcnMocGFyc2VkX3NoZWxsX2NvbW1hbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uY29uZmlybUFuZEV4ZWN1dGVTaGVsbENvbW1hbmQocGFyc2VkX3NoZWxsX2NvbW1hbmQsIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgLmFkZEV4dHJhQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cclxuICAgICAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcChTaGVsbENvbW1hbmRFeHRyYU9wdGlvbnNNb2RhbC5PUFRJT05TX1NVTU1BUlkpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVuIGFuIGV4dHJhIG9wdGlvbnMgbW9kYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1vZGFsID0gbmV3IFNoZWxsQ29tbWFuZEV4dHJhT3B0aW9uc01vZGFsKHRoaXMuYXBwLCB0aGlzLnBsdWdpbiwgc2hlbGxfY29tbWFuZF9pZCwgc2V0dGluZ19ncm91cCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGFsLm9wZW4oKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgLmFkZEV4dHJhQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cclxuICAgICAgICAgICAgICAgICAgICAuc2V0VG9vbHRpcChcIkRlbGV0ZSB0aGlzIHNoZWxsIGNvbW1hbmRcIilcclxuICAgICAgICAgICAgICAgICAgICAuc2V0SWNvbihcInRyYXNoXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVuIGEgZGVsZXRlIG1vZGFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtb2RhbCA9IG5ldyBTaGVsbENvbW1hbmREZWxldGVNb2RhbCh0aGlzLnBsdWdpbiwgc2hlbGxfY29tbWFuZF9pZCwgc2V0dGluZ19ncm91cCwgY29udGFpbmVyX2VsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RhbC5vcGVuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgIC5zZXRDbGFzcyhcInNoZWxsLWNvbW1hbmRzLW5hbWUtc2V0dGluZ1wiKVxyXG4gICAgICAgICAgICAsXHJcbiAgICAgICAgICAgIHNoZWxsX2NvbW1hbmRfc2V0dGluZzpcclxuICAgICAgICAgICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lcl9lbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKFwiRW50ZXIgeW91ciBjb21tYW5kXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHNoZWxsX2NvbW1hbmQpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jIChmaWVsZF92YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2hlbGxfY29tbWFuZCA9IGZpZWxkX3ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nX2dyb3VwLnByZXZpZXdfc2V0dGluZy5zZXREZXNjKHRoaXMuZ2V0U2hlbGxDb21tYW5kUHJldmlldyhzaGVsbF9jb21tYW5kKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfbmV3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNyZWF0aW5nIG5ldyBjb21tYW5kIFwiICsgc2hlbGxfY29tbWFuZF9pZCArIFwiOiBcIiArIHNoZWxsX2NvbW1hbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDb21tYW5kIFwiICsgc2hlbGxfY29tbWFuZF9pZCArIFwiIGdvbm5hIGNoYW5nZSB0bzogXCIgKyBzaGVsbF9jb21tYW5kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gdGhpcyBpbiBib3RoIGNhc2VzLCB3aGVuIGNyZWF0aW5nIGEgbmV3IGNvbW1hbmQgYW5kIHdoZW4gY2hhbmdpbmcgYW4gb2xkIG9uZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLnNoZWxsX2NvbW1hbmQgPSBzaGVsbF9jb21tYW5kO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX25ldykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNvbW1hbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnJlZ2lzdGVyU2hlbGxDb21tYW5kKHNoZWxsX2NvbW1hbmRfaWQsIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNvbW1hbmQgY3JlYXRlZC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgYW4gb2xkIGNvbW1hbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLm9ic2lkaWFuX2NvbW1hbmRzW3NoZWxsX2NvbW1hbmRfaWRdLm5hbWUgPSB0aGlzLnBsdWdpbi5nZW5lcmF0ZU9ic2lkaWFuQ29tbWFuZE5hbWUodGhpcy5wbHVnaW4uZ2V0U2hlbGxDb21tYW5kcygpW3NoZWxsX2NvbW1hbmRfaWRdKTsgLy8gQ2hhbmdlIHRoZSBjb21tYW5kJ3MgbmFtZSBpbiBPYnNpZGlhbidzIGNvbW1hbmQgcGFsZXR0ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29tbWFuZCBjaGFuZ2VkLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgLnNldENsYXNzKFwic2hlbGwtY29tbWFuZHMtc2hlbGwtY29tbWFuZC1zZXR0aW5nXCIpXHJcbiAgICAgICAgICAgICxcclxuICAgICAgICAgICAgcHJldmlld19zZXR0aW5nOlxyXG4gICAgICAgICAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyX2VsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldERlc2ModGhpcy5nZXRTaGVsbENvbW1hbmRQcmV2aWV3KHNoZWxsX2NvbW1hbmQpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRDbGFzcyhcInNoZWxsLWNvbW1hbmRzLXByZXZpZXctc2V0dGluZ1wiKVxyXG4gICAgICAgICAgICAsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gSW5mb3JtYXRpb25hbCBpY29ucyAoPSBub24tY2xpY2thYmxlKVxyXG4gICAgICAgIGxldCBpY29uX2NvbnRhaW5lciA9IHNldHRpbmdfZ3JvdXAubmFtZV9zZXR0aW5nLm5hbWVFbC5jcmVhdGVFbChcInNwYW5cIiwge2F0dHI6IHtjbGFzczogXCJzaGVsbC1jb21tYW5kcy1tYWluLWljb24tY29udGFpbmVyXCJ9fSk7XHJcblxyXG4gICAgICAgIC8vIFwiQXNrIGNvbmZpcm1hdGlvblwiIGljb24uXHJcbiAgICAgICAgbGV0IGNvbmZpcm1fZXhlY3V0aW9uX2ljb25fY29udGFpbmVyID0gaWNvbl9jb250YWluZXIuY3JlYXRlRWwoXCJzcGFuXCIsIHthdHRyOiB7XCJhcmlhLWxhYmVsXCI6IFwiQXNrcyBjb25maXJtYXRpb24gYmVmb3JlIGV4ZWN1dGlvbi5cIiwgY2xhc3M6IFwic2hlbGwtY29tbWFuZHMtY29uZmlybS1leGVjdXRpb24taWNvbi1jb250YWluZXJcIn19KTtcclxuICAgICAgICBzZXRJY29uKGNvbmZpcm1fZXhlY3V0aW9uX2ljb25fY29udGFpbmVyLCBcImxhbmd1YWdlc1wiKTtcclxuICAgICAgICBpZiAoIXNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5jb25maXJtX2V4ZWN1dGlvbikge1xyXG4gICAgICAgICAgICAvLyBEbyBub3QgZGlzcGxheSB0aGUgaWNvbiBmb3IgY29tbWFuZHMgdGhhdCBkbyBub3QgdXNlIGNvbmZpcm1hdGlvbi5cclxuICAgICAgICAgICAgY29uZmlybV9leGVjdXRpb25faWNvbl9jb250YWluZXIuYWRkQ2xhc3MoXCJzaGVsbC1jb21tYW5kcy1oaWRlXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gXCJJZ25vcmVkIGVycm9yIGNvZGVzXCIgaWNvblxyXG4gICAgICAgIGxldCBpZ25vcmVkX2Vycm9yX2NvZGVzX2ljb25fY29udGFpbmVyID0gaWNvbl9jb250YWluZXIuY3JlYXRlRWwoXCJzcGFuXCIsIHthdHRyOiB7XCJhcmlhLWxhYmVsXCI6IHRoaXMuZ2VuZXJhdGVJZ25vcmVkRXJyb3JDb2Rlc0ljb25UaXRsZShzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24uaWdub3JlX2Vycm9yX2NvZGVzKSwgY2xhc3M6IFwic2hlbGwtY29tbWFuZHMtaWdub3JlZC1lcnJvci1jb2Rlcy1pY29uLWNvbnRhaW5lclwifX0pO1xyXG4gICAgICAgIHNldEljb24oaWdub3JlZF9lcnJvcl9jb2Rlc19pY29uX2NvbnRhaW5lciwgXCJzdHJpa2V0aHJvdWdoLWdseXBoXCIpO1xyXG4gICAgICAgIGlmICghc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLmlnbm9yZV9lcnJvcl9jb2Rlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gRG8gbm90IGRpc3BsYXkgdGhlIGljb24gZm9yIGNvbW1hbmRzIHRoYXQgZG8gbm90IGlnbm9yZSBhbnkgZXJyb3JzLlxyXG4gICAgICAgICAgICBpZ25vcmVkX2Vycm9yX2NvZGVzX2ljb25fY29udGFpbmVyLmFkZENsYXNzKFwic2hlbGwtY29tbWFuZHMtaGlkZVwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFkZCBob3RrZXkgaW5mb3JtYXRpb25cclxuICAgICAgICBpZiAoIWlzX25ldykge1xyXG4gICAgICAgICAgICBsZXQgaG90a2V5cyA9IGdldEhvdGtleXNGb3JTaGVsbENvbW1hbmQodGhpcy5wbHVnaW4sIHNoZWxsX2NvbW1hbmRfaWQpO1xyXG4gICAgICAgICAgICBpZiAoaG90a2V5cykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGhvdGtleXNfam9pbmVkOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgaG90a2V5cy5mb3JFYWNoKChob3RrZXk6IEhvdGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChob3RrZXlzX2pvaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3RrZXlzX2pvaW5lZCArPSBcIjxicj5cIlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBob3RrZXlzX2pvaW5lZCArPSBIb3RrZXlUb1N0cmluZyhob3RrZXkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaG90a2V5X2RpdiA9IHNldHRpbmdfZ3JvdXAucHJldmlld19zZXR0aW5nLmNvbnRyb2xFbC5jcmVhdGVFbChcImRpdlwiLCB7IGF0dHI6IHtjbGFzczogXCJzZXR0aW5nLWl0ZW0tZGVzY3JpcHRpb24gc2hlbGwtY29tbWFuZHMtaG90a2V5LWluZm9cIn19KTtcclxuICAgICAgICAgICAgICAgIC8vIENvbW1lbnQgb3V0IHRoZSBpY29uIGJlY2F1c2UgaXQgd291bGQgbG9vayBsaWtlIGEgY2xpY2thYmxlIGJ1dHRvbiAoYXMgdGhlcmUgYXJlIG90aGVyIGNsaWNrYWJsZSBpY29ucyBpbiB0aGUgc2V0dGluZ3MpLlxyXG4gICAgICAgICAgICAgICAgLy8gc2V0SWNvbihob3RrZXlfZGl2LCBcImFueS1rZXlcIiwgMjIpOyAvLyBIb3RrZXkgaWNvblxyXG4gICAgICAgICAgICAgICAgaG90a2V5X2Rpdi5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgXCIgXCIgKyBob3RrZXlzX2pvaW5lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJDcmVhdGVkLlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVOb3RpZmljYXRpb25EdXJhdGlvbkZpZWxkKGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCwgdGl0bGU6IHN0cmluZywgZGVzY3JpcHRpb246IHN0cmluZywgc2V0dGluZ19uYW1lOiBcImVycm9yX21lc3NhZ2VfZHVyYXRpb25cIiB8IFwibm90aWZpY2F0aW9uX21lc3NhZ2VfZHVyYXRpb25cIikge1xyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lcl9lbGVtZW50KVxyXG4gICAgICAgICAgICAuc2V0TmFtZSh0aXRsZSlcclxuICAgICAgICAgICAgLnNldERlc2MoZGVzY3JpcHRpb24gKyBcIiBJbiBzZWNvbmRzLCBiZXR3ZWVuIDEgYW5kIDE4MC5cIilcclxuICAgICAgICAgICAgLmFkZFRleHQoZmllbGQgPT4gZmllbGRcclxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShTdHJpbmcodGhpcy5wbHVnaW4uc2V0dGluZ3Nbc2V0dGluZ19uYW1lXSkpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKGR1cmF0aW9uX3N0cmluZzogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGR1cmF0aW9uOiBudW1iZXIgPSBwYXJzZUludChkdXJhdGlvbl9zdHJpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbiA+PSAxICYmIGR1cmF0aW9uIDw9IDE4MCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNoYW5nZSBcIiArIHNldHRpbmdfbmFtZSArIFwiIGZyb20gXCIgKyB0aGlzLnBsdWdpbi5zZXR0aW5nc1tzZXR0aW5nX25hbWVdICsgXCIgdG8gXCIgKyBkdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzW3NldHRpbmdfbmFtZV0gPSBkdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ2hhbmdlZC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHNob3cgYSBub3RpY2UgaWYgZHVyYXRpb24gaXMgbm90IGJldHdlZW4gMSBhbmQgMTgwLCBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGV2ZXJ5IHRpbWUgYSB1c2VyIHR5cGVzIGluIHRoaXMgZmllbGQsIHNvIHRoZSB2YWx1ZSBtaWdodCBub3QgYmUgZmluYWwuXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFNoZWxsQ29tbWFuZFByZXZpZXcoc2hlbGxfY29tbWFuZDogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IHBhcnNlZF9zaGVsbF9jb21tYW5kID0gcGFyc2VTaGVsbENvbW1hbmRWYXJpYWJsZXModGhpcy5wbHVnaW4sIHNoZWxsX2NvbW1hbmQpOyAvLyBmYWxzZTogZGlzYWJsZXMgbm90aWZpY2F0aW9ucyBpZiB2YXJpYWJsZXMgaGF2ZSBzeW50YXggZXJyb3JzLlxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZF9zaGVsbF9jb21tYW5kKSkge1xyXG4gICAgICAgICAgICAvLyBWYXJpYWJsZSBwYXJzaW5nIGZhaWxlZC5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIGp1c3QgdGhlIGZpcnN0IGVycm9yIG1lc3NhZ2UsIGV2ZW4gaWYgdGhlcmUgYXJlIG11bHRpcGxlIGVycm9ycywgYmVjYXVzZSB0aGUgcHJldmlldyBzcGFjZSBpcyBsaW1pdGVkLlxyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkX3NoZWxsX2NvbW1hbmRbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFZhcmlhYmxlIHBhcnNpbmcgc3VjY2VlZGVkXHJcbiAgICAgICAgcmV0dXJuIHBhcnNlZF9zaGVsbF9jb21tYW5kO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2Nyb2xsX3Bvc2l0aW9uOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSByZW1lbWJlclNjcm9sbFBvc2l0aW9uKGNvbnRhaW5lcl9lbGVtZW50OiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgIGNvbnRhaW5lcl9lbGVtZW50LnNjcm9sbFRvKHtcclxuICAgICAgICAgICAgdG9wOiB0aGlzLnNjcm9sbF9wb3NpdGlvbixcclxuICAgICAgICAgICAgYmVoYXZpb3I6IFwiYXV0b1wiLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnRhaW5lcl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsX3Bvc2l0aW9uID0gY29udGFpbmVyX2VsZW1lbnQuc2Nyb2xsVG9wO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHNoZWxsX2NvbW1hbmRfaWQgU3RyaW5nIGxpa2UgXCIwXCIgb3IgXCIxXCIgZXRjLlxyXG4gICAgICogQHBhcmFtIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvblxyXG4gICAgICogQHB1YmxpYyBQdWJsaWMgYmVjYXVzZSBTaGVsbENvbW1hbmRFeHRyYU9wdGlvbnNNb2RhbCB1c2VzIHRoaXMgdG9vLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2VuZXJhdGVDb21tYW5kRmllbGROYW1lKHNoZWxsX2NvbW1hbmRfaWQ6IHN0cmluZywgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uOiBTaGVsbENvbW1hbmRDb25maWd1cmF0aW9uKSB7XHJcbiAgICAgICAgaWYgKHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5hbGlhcykge1xyXG4gICAgICAgICAgICByZXR1cm4gc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLmFsaWFzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJDb21tYW5kICNcIiArIHNoZWxsX2NvbW1hbmRfaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gaWdub3JlZF9lcnJvcl9jb2Rlc1xyXG4gICAgICogQHB1YmxpYyBQdWJsaWMgYmVjYXVzZSBTaGVsbENvbW1hbmRFeHRyYU9wdGlvbnNNb2RhbCB1c2VzIHRoaXMgdG9vLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2VuZXJhdGVJZ25vcmVkRXJyb3JDb2Rlc0ljb25UaXRsZShpZ25vcmVkX2Vycm9yX2NvZGVzOiBudW1iZXJbXSkge1xyXG4gICAgICAgIGxldCBwbHVyYWwgPSBpZ25vcmVkX2Vycm9yX2NvZGVzLmxlbmd0aCAhPT0gMSA/IFwic1wiIDogXCJcIjtcclxuICAgICAgICByZXR1cm4gXCJJZ25vcmVkIGVycm9yXCIrcGx1cmFsK1wiOiBcIiArIGlnbm9yZWRfZXJyb3JfY29kZXMuam9pbihcIixcIik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2hlbGxDb21tYW5kU2V0dGluZ0dyb3VwIHtcclxuICAgIG5hbWVfc2V0dGluZzogU2V0dGluZztcclxuICAgIHNoZWxsX2NvbW1hbmRfc2V0dGluZzogU2V0dGluZztcclxuICAgIHByZXZpZXdfc2V0dGluZzogU2V0dGluZztcclxufSIsImltcG9ydCB7TW9kYWwsIFNldHRpbmd9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgU2hlbGxDb21tYW5kc1BsdWdpbiBmcm9tIFwiLi9tYWluXCI7XHJcbmltcG9ydCB7U2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbn0gZnJvbSBcIi4vc2V0dGluZ3MvU2hlbGxDb21tYW5kQ29uZmlndXJhdGlvblwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIENvbmZpcm1FeGVjdXRpb25Nb2RhbCBleHRlbmRzIE1vZGFsIHtcclxuICAgIHByaXZhdGUgcGx1Z2luOiBTaGVsbENvbW1hbmRzUGx1Z2luO1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBzaGVsbF9jb21tYW5kOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbjogU2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwbHVnaW46IFNoZWxsQ29tbWFuZHNQbHVnaW4sIHNoZWxsX2NvbW1hbmQ6IHN0cmluZywgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uOiBTaGVsbENvbW1hbmRDb25maWd1cmF0aW9uKSB7XHJcbiAgICAgICAgc3VwZXIocGx1Z2luLmFwcCk7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICAgICAgdGhpcy5zaGVsbF9jb21tYW5kID0gc2hlbGxfY29tbWFuZDtcclxuICAgICAgICB0aGlzLnNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbiA9IHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBvcGVuKCkge1xyXG4gICAgICAgIHN1cGVyLm9wZW4oKTtcclxuXHJcbiAgICAgICAgLy8gSW5mb3JtYXRpb24gYWJvdXQgdGhlIHNoZWxsIGNvbW1hbmRcclxuICAgICAgICB0aGlzLm1vZGFsRWwuY3JlYXRlRWwoXCJoMlwiLCB7dGV4dDogdGhpcy5zaGVsbF9jb21tYW5kLCBhdHRyOiB7c3R5bGU6IFwibWFyZ2luLWJvdHRvbTogMDtcIn19KTtcclxuICAgICAgICBpZiAodGhpcy5zaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24uYWxpYXMpIHtcclxuICAgICAgICAgICAgbGV0IHBhcmFncmFwaCA9IHRoaXMubW9kYWxFbC5jcmVhdGVFbChcInBcIiwge3RleHQ6IFwiQWxpYXM6IFwiICsgdGhpcy5zaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24uYWxpYXMsIGF0dHI6IHtzdHlsZTogXCJtYXJnaW4tdG9wOiAwO1wifX0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1vZGFsRWwuY3JlYXRlRWwoXCJwXCIsIHt0ZXh0OiBcIkV4ZWN1dGUgdGhpcyBzaGVsbCBjb21tYW5kP1wifSk7XHJcblxyXG4gICAgICAgIC8vIEV4ZWN1dGUgYnV0dG9uXHJcbiAgICAgICAgbmV3IFNldHRpbmcodGhpcy5tb2RhbEVsKVxyXG4gICAgICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cclxuICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KFwiWWVzLCBleGVjdXRlIVwiKVxyXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVXNlciBjb25maXJtZWQgZXhlY3V0aW9uIG9mIHNoZWxsIGNvbW1hbmQ6IFwiICsgdGhpcy5zaGVsbF9jb21tYW5kKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5leGVjdXRlU2hlbGxDb21tYW5kKHRoaXMuc2hlbGxfY29tbWFuZCwgdGhpcy5zaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICA7XHJcblxyXG4gICAgfVxyXG59IiwiaW1wb3J0IHtDb21tYW5kLCBOb3RpY2UsIFBsdWdpbn0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQge2V4ZWMsIEV4ZWNFeGNlcHRpb259IGZyb20gXCJjaGlsZF9wcm9jZXNzXCI7XHJcbmltcG9ydCB7Y2xvbmVPYmplY3QsIGdldFZhdWx0QWJzb2x1dGVQYXRofSBmcm9tIFwiLi9Db21tb25cIjtcclxuaW1wb3J0IHtwYXJzZVNoZWxsQ29tbWFuZFZhcmlhYmxlc30gZnJvbSBcIi4vdmFyaWFibGVzL3BhcnNlU2hlbGxDb21tYW5kVmFyaWFibGVzXCI7XHJcbmltcG9ydCB7UnVuTWlncmF0aW9uc30gZnJvbSBcIi4vTWlncmF0aW9uc1wiO1xyXG5pbXBvcnQge1xyXG5cdFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb24sXHJcblx0U2hlbGxDb21tYW5kc0NvbmZpZ3VyYXRpb25cclxufSBmcm9tIFwiLi9zZXR0aW5ncy9TaGVsbENvbW1hbmRDb25maWd1cmF0aW9uXCI7XHJcbmltcG9ydCB7REVGQVVMVF9TRVRUSU5HUywgU2hlbGxDb21tYW5kc1BsdWdpblNldHRpbmdzfSBmcm9tIFwiLi9zZXR0aW5ncy9TaGVsbENvbW1hbmRzUGx1Z2luU2V0dGluZ3NcIjtcclxuaW1wb3J0IHtPYnNpZGlhbkNvbW1hbmRzQ29udGFpbmVyfSBmcm9tIFwiLi9PYnNpZGlhbkNvbW1hbmRzQ29udGFpbmVyXCI7XHJcbmltcG9ydCB7U2hlbGxDb21tYW5kc1NldHRpbmdzVGFifSBmcm9tIFwiLi9zZXR0aW5ncy9TaGVsbENvbW1hbmRzU2V0dGluZ3NUYWJcIjtcclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiO1xyXG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnNcIjtcclxuaW1wb3J0IHtDb25maXJtRXhlY3V0aW9uTW9kYWx9IGZyb20gXCIuL0NvbmZpcm1FeGVjdXRpb25Nb2RhbFwiO1xyXG5pbXBvcnQge2hhbmRsZVNoZWxsQ29tbWFuZE91dHB1dH0gZnJvbSBcIi4vb3V0cHV0X2NoYW5uZWxzL091dHB1dENoYW5uZWxEcml2ZXJGdW5jdGlvbnNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoZWxsQ29tbWFuZHNQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xyXG5cdHNldHRpbmdzOiBTaGVsbENvbW1hbmRzUGx1Z2luU2V0dGluZ3M7XHJcblx0b2JzaWRpYW5fY29tbWFuZHM6IE9ic2lkaWFuQ29tbWFuZHNDb250YWluZXIgPSB7fTtcclxuXHJcblx0LyoqXHJcblx0ICogVGVtcG9yYXJ5IGhvbGRlciBmb3IgU2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbnMgd2hvc2UgdmFyaWFibGVzIGFyZSBhbHJlYWR5IHBhcnNlZCBiZWZvcmUgdGhlIGFjdHVhbCBleGVjdXRpb24gZHVyaW5nIGNvbW1hbmQgcGFsZXR0ZSBwcmV2aWV3LlxyXG5cdCAqIFRoaXMgYXJyYXkgZ2V0cyBlbXB0aWVkIGFmdGVyIGV2ZXJ5IHNoZWxsIGNvbW1hbmQgZXhlY3V0aW9uLlxyXG5cdCAqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRwcml2YXRlIHByZXBhcnNlZF9zaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb25zOiBTaGVsbENvbW1hbmRzQ29uZmlndXJhdGlvbiA9IHt9O1xyXG5cclxuXHRhc3luYyBvbmxvYWQoKSB7XHJcblx0XHRjb25zb2xlLmxvZygnbG9hZGluZyBwbHVnaW4nKTtcclxuXHJcblx0XHRhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xyXG5cclxuXHRcdC8vIFJ1biBwb3NzaWJsZSBjb25maWd1cmF0aW9uIG1pZ3JhdGlvbnNcclxuXHRcdGF3YWl0IFJ1bk1pZ3JhdGlvbnModGhpcyk7XHJcblxyXG5cdFx0Ly8gTWFrZSBhbGwgZGVmaW5lZCBzaGVsbCBjb21tYW5kcyB0byBhcHBlYXIgaW4gdGhlIE9ic2lkaWFuIGNvbW1hbmQgbGlzdFxyXG5cdFx0bGV0IHNoZWxsX2NvbW1hbmRzID0gdGhpcy5nZXRTaGVsbENvbW1hbmRzKCk7XHJcblx0XHRmb3IgKGxldCBjb21tYW5kX2lkIGluIHNoZWxsX2NvbW1hbmRzKSB7XHJcblx0XHRcdGxldCBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24gPSBzaGVsbF9jb21tYW5kc1tjb21tYW5kX2lkXTtcclxuXHRcdFx0dGhpcy5yZWdpc3RlclNoZWxsQ29tbWFuZChjb21tYW5kX2lkLCBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgU2hlbGxDb21tYW5kc1NldHRpbmdzVGFiKHRoaXMuYXBwLCB0aGlzKSk7XHJcblx0fVxyXG5cclxuXHRnZXRTaGVsbENvbW1hbmRzKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0dGluZ3Muc2hlbGxfY29tbWFuZHM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBjb21tYW5kX2lkIHN0cmluZywgYnV0IGluIHByYWN0aXNlIGl0J3MgYSBudW1iZXIgaW4gYSBzdHJpbmcgZm9ybWF0LCBlLmcuIFwiMFwiIG9yIFwiMVwiIGV0Yy5cclxuXHQgKiBAcGFyYW0gc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uXHJcblx0ICovXHJcblx0cmVnaXN0ZXJTaGVsbENvbW1hbmQoY29tbWFuZF9pZDogc3RyaW5nLCBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb246IFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb24pIHtcclxuXHRcdGNvbnNvbGUubG9nKFwiUmVnaXN0ZXJpbmcgc2hlbGwgY29tbWFuZCAjXCIgKyBjb21tYW5kX2lkICsgXCIgKFwiICsgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLnNoZWxsX2NvbW1hbmQgKyBcIikgdG8gT2JzaWRpYW4uLi5cIik7XHJcblx0XHRsZXQgb2JzaWRpYW5fY29tbWFuZDogQ29tbWFuZCA9IHtcclxuXHRcdFx0aWQ6IHRoaXMuZ2VuZXJhdGVPYnNpZGlhbkNvbW1hbmRJZChjb21tYW5kX2lkKSxcclxuXHRcdFx0bmFtZTogdGhpcy5nZW5lcmF0ZU9ic2lkaWFuQ29tbWFuZE5hbWUoc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uKSxcclxuXHRcdFx0Ly8gVXNlICdjaGVja0NhbGxiYWNrJyBpbnN0ZWFkIG9mIG5vcm1hbCAnY2FsbGJhY2snIGJlY2F1c2Ugd2UgYWxzbyB3YW50IHRvIGdldCBjYWxsZWQgd2hlbiB0aGUgY29tbWFuZCBwYWxldHRlIGlzIG9wZW5lZC5cclxuXHRcdFx0Y2hlY2tDYWxsYmFjazogKGlzX29wZW5pbmdfY29tbWFuZF9wYWxldHRlKSA9PiB7XHJcblx0XHRcdFx0aWYgKGlzX29wZW5pbmdfY29tbWFuZF9wYWxldHRlKSB7XHJcblx0XHRcdFx0XHQvLyBUaGUgdXNlciBpcyBjdXJyZW50bHkgb3BlbmluZyB0aGUgY29tbWFuZCBwYWxldHRlLlxyXG5cdFx0XHRcdFx0Ly8gRG8gbm90IGV4ZWN1dGUgdGhlIGNvbW1hbmQgeWV0LCBidXQgcGFyc2UgdmFyaWFibGVzIGZvciBwcmV2aWV3LCBpZiBlbmFibGVkIGluIHRoZSBzZXR0aW5ncy5cclxuXHRcdFx0XHRcdGlmICh0aGlzLnNldHRpbmdzLnByZXZpZXdfdmFyaWFibGVzX2luX2NvbW1hbmRfcGFsZXR0ZSkge1xyXG5cdFx0XHRcdFx0XHRsZXQgcHJlcGFyc2VkX3NoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbjogU2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbiA9IGNsb25lT2JqZWN0KHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbik7IC8vIENsb25lIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbiBzbyB0aGF0IHdlIHdvbid0IGVkaXQgdGhlIG9yaWdpbmFsIG9iamVjdC5cclxuXHJcblx0XHRcdFx0XHRcdC8vIFBhcnNlIHZhcmlhYmxlcyBpbiB0aGUgYWN0dWFsIHNoZWxsIGNvbW1hbmRcclxuXHRcdFx0XHRcdFx0bGV0IHBhcnNlZF9zaGVsbF9jb21tYW5kID0gcGFyc2VTaGVsbENvbW1hbmRWYXJpYWJsZXModGhpcywgcHJlcGFyc2VkX3NoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5zaGVsbF9jb21tYW5kKTtcclxuXHRcdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkocGFyc2VkX3NoZWxsX2NvbW1hbmQpKSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gVmFyaWFibGUgcGFyc2luZyBmYWlsZWQsIGJlY2F1c2UgYW4gYXJyYXkgd2FzIHJldHVybmVkLCB3aGljaCBjb250YWlucyBlcnJvciBtZXNzYWdlcy5cclxuXHRcdFx0XHRcdFx0XHQvLyBKdXN0IGNhbmNlbCB0aGUgcHJldmlldywgdGhlIGNvbW1hbmQgd2lsbCBiZSBzaG93biB3aXRoIHZhcmlhYmxlIG5hbWVzLiBEaXNjYXJkIHRoZSBlcnJvciBtZXNzYWdlcy5cclxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIlNoZWxsIGNvbW1hbmQgcHJldmlldzogVmFyaWFibGUgcGFyc2luZyBmYWlsZWQgZm9yIHNoZWxsIGNvbW1hbmQgXCIgKyBwcmVwYXJzZWRfc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLnNoZWxsX2NvbW1hbmQpO1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdC8vIFZhcmlhYmxlIHBhcnNpbmcgc3VjY2VlZGVkLlxyXG5cdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgcGFyc2VkIHZhbHVlcy5cclxuXHRcdFx0XHRcdFx0XHRwcmVwYXJzZWRfc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLnNoZWxsX2NvbW1hbmQgPSBwYXJzZWRfc2hlbGxfY29tbWFuZDtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gQWxzbyBwYXJzZSB2YXJpYWJsZXMgaW4gYW4gYWxpYXMsIGluIGNhc2UgdGhlIGNvbW1hbmQgaGFzIG9uZS4gVmFyaWFibGVzIGluIGFsaWFzZXMgZG8gbm90IGRvIGFueXRoaW5nIHByYWN0aWNhbCwgYnV0IHRoZXkgY2FuIHJldmVhbCB0aGUgdXNlciB3aGF0IHZhcmlhYmxlcyBhcmUgdXNlZCBpbiB0aGUgY29tbWFuZC5cclxuXHRcdFx0XHRcdFx0bGV0IHBhcnNlZF9hbGlhcyA9IHBhcnNlU2hlbGxDb21tYW5kVmFyaWFibGVzKHRoaXMsIHByZXBhcnNlZF9zaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24uYWxpYXMpO1xyXG5cdFx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRfYWxpYXMpKSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gVmFyaWFibGUgcGFyc2luZyBmYWlsZWQsIGJlY2F1c2UgYW4gYXJyYXkgd2FzIHJldHVybmVkLCB3aGljaCBjb250YWlucyBlcnJvciBtZXNzYWdlcy5cclxuXHRcdFx0XHRcdFx0XHQvLyBKdXN0IGNhbmNlbCB0aGUgcHJldmlldywgdGhlIGFsaWFzIHdpbGwgYmUgc2hvd24gd2l0aCB2YXJpYWJsZSBuYW1lcy4gRGlzY2FyZCB0aGUgZXJyb3IgbWVzc2FnZXMuXHJcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJTaGVsbCBjb21tYW5kIHByZXZpZXc6IFZhcmlhYmxlIHBhcnNpbmcgZmFpbGVkIGZvciBhbGlhcyBcIiArIHByZXBhcnNlZF9zaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24uYWxpYXMpO1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdC8vIFZhcmlhYmxlIHBhcnNpbmcgc3VjY2VlZGVkLlxyXG5cdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgcGFyc2VkIHZhbHVlcy5cclxuXHRcdFx0XHRcdFx0XHRwcmVwYXJzZWRfc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLmFsaWFzID0gcGFyc2VkX2FsaWFzO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBSZW5hbWUgdGhlIGNvbW1hbmQgaW4gY29tbWFuZCBwYWxldHRlXHJcblx0XHRcdFx0XHRcdGxldCBwcmVmaXggPSB0aGlzLmdldFBsdWdpbk5hbWUoKSArIFwiOiBcIjsgLy8gTm9ybWFsbHkgT2JzaWRpYW4gcHJlZml4ZXMgYWxsIGNvbW1hbmRzIHdpdGggdGhlIHBsdWdpbiBuYW1lIGF1dG9tYXRpY2FsbHksIGJ1dCBub3cgdGhhdCB3ZSBhcmUgYWN0dWFsbHkgX2VkaXRpbmdfIGEgY29tbWFuZCBpbiB0aGUgcGFsZXR0ZSAobm90IGNyZWF0aW5nIGEgbmV3IG9uZSksIE9ic2lkaWFuIHdvbid0IGRvIHRoZSBwcmVmaXhpbmcgZm9yIHVzLlxyXG5cdFx0XHRcdFx0XHRvYnNpZGlhbl9jb21tYW5kLm5hbWUgPSBwcmVmaXggKyB0aGlzLmdlbmVyYXRlT2JzaWRpYW5Db21tYW5kTmFtZShwcmVwYXJzZWRfc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uKTtcclxuXHJcblx0XHRcdFx0XHRcdC8vIFN0b3JlIHRoZSBwcmVwYXJzZWQgc2hlbGwgY29tbWFuZCBzbyB0aGF0IHdlIGNhbiB1c2UgZXhhY3RseSB0aGUgc2FtZSB2YWx1ZXMgaWYgdGhlIGNvbW1hbmQgZ2V0cyBsYXRlciBleGVjdXRlZC5cclxuXHRcdFx0XHRcdFx0dGhpcy5wcmVwYXJzZWRfc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uc1tjb21tYW5kX2lkXSA9IHByZXBhcnNlZF9zaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb247XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTsgLy8gTmVlZCB0byByZXR1cm4gdHJ1ZSwgb3RoZXJ3aXNlIHRoZSBjb21tYW5kIHdvdWxkIGJlIGxlZnQgb3V0IGZyb20gdGhlIGNvbW1hbmQgcGFsZXR0ZS5cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vIFRoZSB1c2VyIGhhcyBpbnN0cnVjdGVkIHRvIGV4ZWN1dGUgdGhlIGNvbW1hbmQuXHJcblx0XHRcdFx0XHQvLyBDaGVjayBpZiB3ZSBoYXBwZW4gdG8gaGF2ZSBhIHByZXBhcnNlZCBjb21tYW5kICg9IHZhcmlhYmxlcyBwYXJzZWQgYXQgdGhlIHRpbWUgb2Ygb3BlbmluZyB0aGUgY29tbWFuZCBwYWxldHRlKVxyXG5cdFx0XHRcdFx0aWYgKHVuZGVmaW5lZCA9PT0gdGhpcy5wcmVwYXJzZWRfc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uc1tjb21tYW5kX2lkXSkge1xyXG5cdFx0XHRcdFx0XHQvLyBObyBwcmVwYXJzZWQgY29tbWFuZC4gRXhlY3V0ZSBhIHN0YW5kYXJkIHZlcnNpb24gb2YgdGhlIGNvbW1hbmQsIGFuZCBkbyB2YXJpYWJsZSBwYXJzaW5nIG5vdy5cclxuXHRcdFx0XHRcdFx0bGV0IHBhcnNlZF9zaGVsbF9jb21tYW5kID0gcGFyc2VTaGVsbENvbW1hbmRWYXJpYWJsZXModGhpcywgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLnNoZWxsX2NvbW1hbmQpO1xyXG5cdFx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRfc2hlbGxfY29tbWFuZCkpIHtcclxuXHRcdFx0XHRcdFx0XHQvLyBUaGUgY29tbWFuZCBjb3VsZCBub3QgYmUgcGFyc2VkIGNvcnJlY3RseS5cclxuXHRcdFx0XHRcdFx0XHQvLyBEaXNwbGF5IGVycm9yIG1lc3NhZ2VzXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5uZXdFcnJvcnMocGFyc2VkX3NoZWxsX2NvbW1hbmQpO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdC8vIFRoZSBjb21tYW5kIHdhcyBwYXJzZWQgY29ycmVjdGx5LlxyXG5cdFx0XHRcdFx0XHRcdHRoaXMuY29uZmlybUFuZEV4ZWN1dGVTaGVsbENvbW1hbmQocGFyc2VkX3NoZWxsX2NvbW1hbmQsIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbik7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHQvLyBXZSBkbyBoYXZlIGEgcHJlcGFyc2VkIHZlcnNpb24gb2YgdGhpcyBjb21tYW5kLlxyXG5cdFx0XHRcdFx0XHQvLyBObyBuZWVkIHRvIGNoZWNrIGlmIHRoZSBwYXJzaW5nIGhhZCBwcmV2aW91c2x5IHN1Y2NlZWRlZCwgYmVjYXVzZSBpZiBpdCB3b3VsZCBoYXZlIGZhaWxlZCwgdGhlIGNvbW1hbmQgd291bGQgbm90IGJlIGluIHRoZSBwcmVwYXJzZWQgY29tbWFuZHMnIGFycmF5LlxyXG5cdFx0XHRcdFx0XHR0aGlzLmNvbmZpcm1BbmRFeGVjdXRlU2hlbGxDb21tYW5kKHRoaXMucHJlcGFyc2VkX3NoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbnNbY29tbWFuZF9pZF0uc2hlbGxfY29tbWFuZCwgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyBEZWxldGUgdGhlIHdob2xlIGFycmF5IG9mIHByZXBhcnNlZCBjb21tYW5kcy4gRXZlbiB0aG91Z2ggd2Ugb25seSB1c2VkIGp1c3Qgb25lIGNvbW1hbmQgZnJvbSBpdCwgd2UgbmVlZCB0byBub3RpY2UgdGhhdCBvcGVuaW5nIGEgY29tbWFuZFxyXG5cdFx0XHRcdFx0Ly8gcGFsZXR0ZSBtaWdodCBnZW5lcmF0ZSBtdWx0aXBsZSBwcmVwYXJzZWQgY29tbWFuZHMgaW4gdGhlIGFycmF5LCBidXQgYXMgdGhlIHVzZXIgc2VsZWN0cyBhbmQgZXhlY3V0ZXMgb25seSBvbmUgY29tbWFuZCwgYWxsIHRoZXNlIHRlbXBvcmFyeVxyXG5cdFx0XHRcdFx0Ly8gY29tbWFuZHMgYXJlIG5vdyBvYnNvbGV0ZS4gRGVsZXRlIHRoZW0ganVzdCBpbiBjYXNlIHRoZSB1c2VyIHRvZ2dsZXMgdGhlIHZhcmlhYmxlIHByZXZpZXcgZmVhdHVyZSBvZmYgaW4gdGhlIHNldHRpbmdzLiBXZSBkbyBub3Qgd2FudCB0b1xyXG5cdFx0XHRcdFx0Ly8gZXhlY3V0ZSBvYnNvbGV0ZSBjb21tYW5kcyBhY2NpZGVudGFsbHkuIFRoaXMgZGVsZXRpb24gYWxzbyBuZWVkcyB0byBiZSBkb25lIGV2ZW4gaWYgdGhlIGV4ZWN1dGVkIGNvbW1hbmQgd2FzIG5vdCBhIHByZXBhcnNlZCBjb21tYW5kLCBiZWNhdXNlXHJcblx0XHRcdFx0XHQvLyBldmVuIHdoZW4gcHJlcGFyc2luZyBpcyB0dXJuZWQgb24gaW4gdGhlIHNldHRpbmdzLCBzaW5ndWxhciBjb21tYW5kcyBtYXkgZmFpbCB0byBwYXJzZSBhbmQgdGhlcmVmb3JlIHRoZXkgd291bGQgbm90IGJlIGluIHRoaXMgYXJyYXksIGJ1dCBvdGhlclxyXG5cdFx0XHRcdFx0Ly8gY29tbWFuZHMgbWlnaHQgYmUuXHJcblx0XHRcdFx0XHR0aGlzLnJlc2V0UHJlcGFyc2VkU2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbnMoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0XHR0aGlzLmFkZENvbW1hbmQob2JzaWRpYW5fY29tbWFuZClcclxuXHRcdHRoaXMub2JzaWRpYW5fY29tbWFuZHNbY29tbWFuZF9pZF0gPSBvYnNpZGlhbl9jb21tYW5kOyAvLyBTdG9yZSB0aGUgcmVmZXJlbmNlIHNvIHRoYXQgd2UgY2FuIGVkaXQgdGhlIGNvbW1hbmQgbGF0ZXIgaW4gU2hlbGxDb21tYW5kc1NldHRpbmdzVGFiIGlmIG5lZWRlZC5cclxuXHRcdGNvbnNvbGUubG9nKFwiUmVnaXN0ZXJlZC5cIilcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGxlZCB3aGVuIGl0J3Mga25vd24gdGhhdCBwcmVwYXJzZWQgc2hlbGwgY29tbWFuZCB2YXJpYWJsZXMgaGF2ZSBvbGQgZGF0YSBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIGxhdGVyLlxyXG5cdCAqL1xyXG5cdHJlc2V0UHJlcGFyc2VkU2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbnMoKSB7XHJcblx0XHR0aGlzLnByZXBhcnNlZF9zaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb25zID0ge307XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDYWxsZWQgYWZ0ZXIgdHVybmluZyBcIlByZXZpZXcgdmFyaWFibGVzIGluIGNvbW1hbmQgcGFsZXR0ZVwiIHNldHRpbmcgb2ZmLCB0byBtYWtlIHN1cmUgdGhhdCBhbGwgc2hlbGwgY29tbWFuZHMgaGF2ZSB7e3ZhcmlhYmxlfX0gbmFtZXMgdmlzaWJsZSBpbnN0ZWFkIG9mIHRoZWlyIHZhbHVlcy5cclxuXHQgKi9cclxuXHRyZXNldENvbW1hbmRQYWxldHRlTmFtZXMoKSB7XHJcblx0XHRsZXQgc2hlbGxfY29tbWFuZHMgPSB0aGlzLmdldFNoZWxsQ29tbWFuZHMoKTtcclxuXHRcdGZvciAobGV0IHNoZWxsX2NvbW1hbmRfaWQgaW4gc2hlbGxfY29tbWFuZHMpIHtcclxuXHRcdFx0bGV0IHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbiA9IHNoZWxsX2NvbW1hbmRzW3NoZWxsX2NvbW1hbmRfaWRdO1xyXG5cdFx0XHR0aGlzLm9ic2lkaWFuX2NvbW1hbmRzW3NoZWxsX2NvbW1hbmRfaWRdLm5hbWUgPSB0aGlzLmdlbmVyYXRlT2JzaWRpYW5Db21tYW5kTmFtZShzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGVPYnNpZGlhbkNvbW1hbmRJZChzaGVsbF9jb21tYW5kX2lkOiBzdHJpbmcpIHtcclxuXHRcdHJldHVybiBcInNoZWxsLWNvbW1hbmQtXCIgKyBzaGVsbF9jb21tYW5kX2lkO1xyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGVPYnNpZGlhbkNvbW1hbmROYW1lKHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbjogU2hlbGxDb21tYW5kQ29uZmlndXJhdGlvbikge1xyXG5cdFx0bGV0IHByZWZpeCA9IFwiRXhlY3V0ZTogXCI7XHJcblx0XHRpZiAoc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLmFsaWFzKSB7XHJcblx0XHRcdC8vIElmIGFuIGFsaWFzIGlzIHNldCBmb3IgdGhlIGNvbW1hbmQsIE9ic2lkaWFuJ3MgY29tbWFuZCBwYWxldHRlIHNob3VsZCBkaXNwbGF5IHRoZSBhbGlhcyB0ZXh0IGluc3RlYWQgb2YgdGhlIGFjdHVhbCBjb21tYW5kLlxyXG5cdFx0XHRyZXR1cm4gcHJlZml4ICsgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLmFsaWFzO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHByZWZpeCArIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5zaGVsbF9jb21tYW5kO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gc2hlbGxfY29tbWFuZCBUaGUgYWN0dWFsIHNoZWxsIGNvbW1hbmQgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkLlxyXG5cdCAqIEBwYXJhbSBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24gVXNlZCBmb3IgcmVhZGluZyBvdGhlciBwcm9wZXJ0aWVzLiBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24uc2hlbGxfY29tbWFuZCB3b24ndCBiZSB1c2VkIVxyXG5cdCAqL1xyXG5cdGNvbmZpcm1BbmRFeGVjdXRlU2hlbGxDb21tYW5kKHNoZWxsX2NvbW1hbmQ6IHN0cmluZywgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uOiBTaGVsbENvbW1hbmRDb25maWd1cmF0aW9uKSB7XHJcblxyXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIGNvbW1hbmQgbmVlZHMgY29uZmlybWF0aW9uIGJlZm9yZSBleGVjdXRpb25cclxuXHRcdGlmIChzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24uY29uZmlybV9leGVjdXRpb24pIHtcclxuXHRcdFx0Ly8gWWVzLCBhIGNvbmZpcm1hdGlvbiBpcyBuZWVkZWQuXHJcblx0XHRcdC8vIE9wZW4gYSBjb25maXJtYXRpb24gbW9kYWwuXHJcblx0XHRcdG5ldyBDb25maXJtRXhlY3V0aW9uTW9kYWwodGhpcywgc2hlbGxfY29tbWFuZCwgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uKVxyXG5cdFx0XHRcdC5vcGVuKClcclxuXHRcdFx0O1xyXG5cdFx0XHRyZXR1cm47IC8vIERvIG5vdCBleGVjdXRlIG5vdy4gVGhlIG1vZGFsIHdpbGwgY2FsbCBleGVjdXRlU2hlbGxDb21tYW5kKCkgbGF0ZXIgaWYgbmVlZGVkLlxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gTm8gbmVlZCB0byBjb25maXJtLlxyXG5cdFx0XHQvLyBFeGVjdXRlLlxyXG5cdFx0XHR0aGlzLmV4ZWN1dGVTaGVsbENvbW1hbmQoc2hlbGxfY29tbWFuZCwgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERvZXMgbm90IGFzayBmb3IgY29uZmlybWF0aW9uIGJlZm9yZSBleGVjdXRpb24uIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGlmOiBhKSBhIGNvbmZpcm1hdGlvbiBpcyBhbHJlYWR5IGFza2VkIGZyb20gYSB1c2VyLCBvciBiKSB0aGlzIGNvbW1hbmQgaXMgZGVmaW5lZCBub3QgdG8gbmVlZCBhIGNvbmZpcm1hdGlvbi5cclxuXHQgKiBVc2UgY29uZmlybUFuZEV4ZWN1dGVTaGVsbENvbW1hbmQoKSBpbnN0ZWFkIHRvIGhhdmUgYSBjb25maXJtYXRpb24gYXNrZWQgYmVmb3JlIHRoZSBleGVjdXRpb24uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gc2hlbGxfY29tbWFuZCBUaGUgYWN0dWFsIHNoZWxsIGNvbW1hbmQgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkLlxyXG5cdCAqIEBwYXJhbSBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24gVXNlZCBmb3IgcmVhZGluZyBvdGhlciBwcm9wZXJ0aWVzLiBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb24uc2hlbGxfY29tbWFuZCB3b24ndCBiZSB1c2VkIVxyXG5cdCAqL1xyXG5cdGV4ZWN1dGVTaGVsbENvbW1hbmQoc2hlbGxfY29tbWFuZDogc3RyaW5nLCBzaGVsbF9jb21tYW5kX2NvbmZpZ3VyYXRpb246IFNoZWxsQ29tbWFuZENvbmZpZ3VyYXRpb24pIHtcclxuXHRcdGxldCB3b3JraW5nX2RpcmVjdG9yeSA9IHRoaXMuZ2V0V29ya2luZ0RpcmVjdG9yeSgpO1xyXG5cclxuXHRcdC8vIENoZWNrIHRoYXQgdGhlIHNoZWxsIGNvbW1hbmQgaXMgbm90IGVtcHR5XHJcblx0XHRzaGVsbF9jb21tYW5kID0gc2hlbGxfY29tbWFuZC50cmltKCk7XHJcblx0XHRpZiAoIXNoZWxsX2NvbW1hbmQubGVuZ3RoKSB7XHJcblx0XHRcdC8vIEl0IGlzIGVtcHR5XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiVGhlIHNoZWxsIGNvbW1hbmQgaXMgZW1wdHkuIDooXCIpO1xyXG5cdFx0XHR0aGlzLm5ld0Vycm9yKFwiVGhlIHNoZWxsIGNvbW1hbmQgaXMgZW1wdHkgOihcIik7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBDaGVjayB0aGF0IHRoZSB3b3JraW5nIGRpcmVjdG9yeSBleGlzdHMgYW5kIGlzIGEgZm9sZGVyXHJcblx0XHRpZiAoIWZzLmV4aXN0c1N5bmMod29ya2luZ19kaXJlY3RvcnkpKSB7XHJcblx0XHRcdC8vIFdvcmtpbmcgZGlyZWN0b3J5IGRvZXMgbm90IGV4aXN0XHJcblx0XHRcdC8vIFByZXZlbnQgZXhlY3V0aW9uXHJcblx0XHRcdGNvbnNvbGUubG9nKFwiV29ya2luZyBkaXJlY3RvcnkgZG9lcyBub3QgZXhpc3Q6IFwiICsgd29ya2luZ19kaXJlY3RvcnkpO1xyXG5cdFx0XHR0aGlzLm5ld0Vycm9yKFwiV29ya2luZyBkaXJlY3RvcnkgZG9lcyBub3QgZXhpc3Q6IFwiICsgd29ya2luZ19kaXJlY3RvcnkpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAoIWZzLmxzdGF0U3luYyh3b3JraW5nX2RpcmVjdG9yeSkuaXNEaXJlY3RvcnkoKSkge1xyXG5cdFx0XHQvLyBXb3JraW5nIGRpcmVjdG9yeSBpcyBub3QgYSBkaXJlY3RvcnkuXHJcblx0XHRcdC8vIFByZXZlbnQgZXhlY3V0aW9uXHJcblx0XHRcdGNvbnNvbGUubG9nKFwiV29ya2luZyBkaXJlY3RvcnkgZXhpc3RzIGJ1dCBpcyBub3QgYSBmb2xkZXI6IFwiICsgd29ya2luZ19kaXJlY3RvcnkpO1xyXG5cdFx0XHR0aGlzLm5ld0Vycm9yKFwiV29ya2luZyBkaXJlY3RvcnkgZXhpc3RzIGJ1dCBpcyBub3QgYSBmb2xkZXI6IFwiICsgd29ya2luZ19kaXJlY3RvcnkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gV29ya2luZyBkaXJlY3RvcnkgaXMgT0tcclxuXHRcdFx0Ly8gRXhlY3V0ZSB0aGUgc2hlbGwgY29tbWFuZFxyXG5cdFx0XHRjb25zb2xlLmxvZyhcIkV4ZWN1dGluZyBjb21tYW5kIFwiICsgc2hlbGxfY29tbWFuZCArIFwiIGluIFwiICsgd29ya2luZ19kaXJlY3RvcnkgKyBcIi4uLlwiKTtcclxuXHRcdFx0ZXhlYyhzaGVsbF9jb21tYW5kLCB7XHJcblx0XHRcdFx0XCJjd2RcIjogd29ya2luZ19kaXJlY3RvcnlcclxuXHRcdFx0fSwgKGVycm9yOiBFeGVjRXhjZXB0aW9ufG51bGwsIHN0ZG91dDogc3RyaW5nLCBzdGRlcnI6IHN0cmluZykgPT4ge1xyXG5cdFx0XHRcdGlmIChudWxsICE9PSBlcnJvcikge1xyXG5cdFx0XHRcdFx0Ly8gU29tZSBlcnJvciBvY2N1cnJlZFxyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJDb21tYW5kIGV4ZWN1dGVkIGFuZCBmYWlsZWQuIEVycm9yIG51bWJlcjogXCIgKyBlcnJvci5jb2RlICsgXCIuIE1lc3NhZ2U6IFwiICsgZXJyb3IubWVzc2FnZSk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgaWYgdGhpcyBlcnJvciBzaG91bGQgYmUgZGlzcGxheWVkIHRvIHRoZSB1c2VyIG9yIG5vdFxyXG5cdFx0XHRcdFx0aWYgKHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbi5pZ25vcmVfZXJyb3JfY29kZXMuY29udGFpbnMoZXJyb3IuY29kZSkpIHtcclxuXHRcdFx0XHRcdFx0Ly8gVGhlIHVzZXIgaGFzIGlnbm9yZWQgdGhpcyBlcnJvci5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJVc2VyIGhhcyBpZ25vcmVkIHRoaXMgZXJyb3IsIHNvIHdvbid0IGRpc3BsYXkgaXQuXCIpO1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIG9ubHkgc3Rkb3V0IG91dHB1dCBzdHJlYW1cclxuXHRcdFx0XHRcdFx0aGFuZGxlU2hlbGxDb21tYW5kT3V0cHV0KHRoaXMsIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbiwgc3Rkb3V0LCBcIlwiLCBudWxsKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdC8vIFNob3cgdGhlIGVycm9yLlxyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIldpbGwgZGlzcGxheSB0aGUgZXJyb3IgdG8gdXNlci5cIik7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBDaGVjayB0aGF0IHN0ZGVyciBhY3R1YWxseSBjb250YWlucyBhbiBlcnJvciBtZXNzYWdlXHJcblx0XHRcdFx0XHRcdGlmICghc3RkZXJyLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRcdC8vIFN0ZGVyciBpcyBlbXB0eSwgc28gdGhlIGVycm9yIG1lc3NhZ2UgaXMgcHJvYmFibHkgZ2l2ZW4gYnkgTm9kZS5qcydzIGNoaWxkX3Byb2Nlc3MuXHJcblx0XHRcdFx0XHRcdFx0Ly8gRGlyZWN0IGVycm9yLm1lc3NhZ2UgdG8gdGhlIHN0ZGVyciB2YXJpYWJsZSwgc28gdGhhdCB0aGUgdXNlciBjYW4gc2VlIGVycm9yLm1lc3NhZ2Ugd2hlbiBzdGRlcnIgaXMgdW5hdmFpbGFibGUuXHJcblx0XHRcdFx0XHRcdFx0c3RkZXJyID0gZXJyb3IubWVzc2FnZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGJvdGggc3Rkb3V0IGFuZCBzdGRlcnIgb3V0cHV0IHN0cmVhbXNcclxuXHRcdFx0XHRcdFx0aGFuZGxlU2hlbGxDb21tYW5kT3V0cHV0KHRoaXMsIHNoZWxsX2NvbW1hbmRfY29uZmlndXJhdGlvbiwgc3Rkb3V0LCBzdGRlcnIsIGVycm9yLmNvZGUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvLyBObyBlcnJvcnNcclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiQ29tbWFuZCBleGVjdXRlZCB3aXRob3V0IGVycm9ycy5cIilcclxuXHJcblx0XHRcdFx0XHQvLyBIYW5kbGUgb3V0cHV0XHJcblx0XHRcdFx0XHRoYW5kbGVTaGVsbENvbW1hbmRPdXRwdXQodGhpcywgc2hlbGxfY29tbWFuZF9jb25maWd1cmF0aW9uLCBzdGRvdXQsIHN0ZGVyciwgMCk7IC8vIFVzZSB6ZXJvIGFzIGFuIGVycm9yIGNvZGUgaW5zdGVhZCBvZiBudWxsICgwIG1lYW5zIG5vIGVycm9yKS4gSWYgc3RkZXJyIGhhcHBlbnMgdG8gY29udGFpbiBzb21ldGhpbmcsIGV4aXQgY29kZSAwIGdldHMgZGlzcGxheWVkIGluIGFuIGVycm9yIGJhbGxvb24gKGlmIHRoYXQgaXMgc2VsZWN0ZWQgYXMgYSBkcml2ZXIgZm9yIHN0ZGVycikuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGdldFdvcmtpbmdEaXJlY3RvcnkoKSB7XHJcblx0XHQvLyBSZXR1cm5zIGVpdGhlciBhIHVzZXIgZGVmaW5lZCB3b3JraW5nIGRpcmVjdG9yeSwgb3IgYW4gYXV0b21hdGljYWxseSBkZXRlY3RlZCBvbmUuXHJcblx0XHRsZXQgd29ya2luZ19kaXJlY3RvcnkgPSB0aGlzLnNldHRpbmdzLndvcmtpbmdfZGlyZWN0b3J5O1xyXG5cdFx0aWYgKHdvcmtpbmdfZGlyZWN0b3J5Lmxlbmd0aCA9PSAwKSB7XHJcblx0XHRcdC8vIE5vIHdvcmtpbmcgZGlyZWN0b3J5IHNwZWNpZmllZCwgc28gdXNlIHRoZSB2YXVsdCBkaXJlY3RvcnkuXHJcblx0XHRcdHJldHVybiBnZXRWYXVsdEFic29sdXRlUGF0aCh0aGlzLmFwcCk7XHJcblx0XHR9IGVsc2UgaWYgKCFwYXRoLmlzQWJzb2x1dGUod29ya2luZ19kaXJlY3RvcnkpKSB7XHJcblx0XHRcdC8vIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBpcyByZWxhdGl2ZS5cclxuXHRcdFx0Ly8gSGVscCB0byBtYWtlIGl0IHJlZmVyIHRvIHRoZSB2YXVsdCdzIGRpcmVjdG9yeS4gV2l0aG91dCB0aGlzLCB0aGUgcmVsYXRpdmUgcGF0aCB3b3VsZCByZWZlciB0byBPYnNpZGlhbidzIGluc3RhbGxhdGlvbiBkaXJlY3RvcnkgKGF0IGxlYXN0IG9uIFdpbmRvd3MpLlxyXG5cdFx0XHRyZXR1cm4gcGF0aC5qb2luKGdldFZhdWx0QWJzb2x1dGVQYXRoKHRoaXMuYXBwKSwgd29ya2luZ19kaXJlY3RvcnkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHdvcmtpbmdfZGlyZWN0b3J5O1xyXG5cdH1cclxuXHJcblx0b251bmxvYWQoKSB7XHJcblx0XHRjb25zb2xlLmxvZygndW5sb2FkaW5nIHBsdWdpbicpO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgbG9hZFNldHRpbmdzKCkge1xyXG5cdFx0dGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSk7XHJcblx0fVxyXG5cclxuXHRhc3luYyBzYXZlU2V0dGluZ3MoKSB7XHJcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQHJldHVybiBzdHJpbmcgUmV0dXJucyBcIjBcIiBpZiB0aGVyZSBhcmUgbm8gc2hlbGwgY29tbWFuZHMgeWV0LCBvdGhlcndpc2UgcmV0dXJucyB0aGUgbWF4IElEICsgMSwgYXMgYSBzdHJpbmcuXHJcblx0ICovXHJcblx0Z2VuZXJhdGVOZXdTaGVsbENvbW1hbmRJRCgpIHtcclxuXHRcdGxldCBleGlzdGluZ19pZHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLmdldFNoZWxsQ29tbWFuZHMoKSk7XHJcblx0XHRsZXQgbmV3X2lkID0gMDtcclxuXHRcdGZvciAobGV0IGkgaW4gZXhpc3RpbmdfaWRzKSB7XHJcblx0XHRcdGxldCBleGlzdGluZ19pZCA9IHBhcnNlSW50KGV4aXN0aW5nX2lkc1tpXSk7XHJcblx0XHRcdGlmIChleGlzdGluZ19pZCA+PSBuZXdfaWQpIHtcclxuXHRcdFx0XHRuZXdfaWQgPSBleGlzdGluZ19pZCArIDE7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBTdHJpbmcobmV3X2lkKTtcclxuXHR9XHJcblxyXG5cdGdldFBsdWdpbklkKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWFuaWZlc3QuaWQ7XHJcblx0fVxyXG5cclxuXHRnZXRQbHVnaW5OYW1lKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWFuaWZlc3QubmFtZTtcclxuXHR9XHJcblxyXG5cdG5ld0Vycm9yKG1lc3NhZ2U6IHN0cmluZykge1xyXG5cdFx0bmV3IE5vdGljZShtZXNzYWdlLCB0aGlzLnNldHRpbmdzLmVycm9yX21lc3NhZ2VfZHVyYXRpb24gKiAxMDAwKTsgLy8gKiAxMDAwID0gY29udmVydCBzZWNvbmRzIHRvIG1pbGxpc2Vjb25kcy5cclxuXHR9XHJcblxyXG5cdG5ld0Vycm9ycyhtZXNzYWdlczogc3RyaW5nW10pIHtcclxuXHRcdG1lc3NhZ2VzLmZvckVhY2goKG1lc3NhZ2U6IHN0cmluZykgPT4ge1xyXG5cdFx0XHR0aGlzLm5ld0Vycm9yKG1lc3NhZ2UpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRuZXdOb3RpZmljYXRpb24obWVzc2FnZTogc3RyaW5nKSB7XHJcblx0XHRuZXcgTm90aWNlKG1lc3NhZ2UsIHRoaXMuc2V0dGluZ3Mubm90aWZpY2F0aW9uX21lc3NhZ2VfZHVyYXRpb24gKiAxMDAwKTsgLy8gKiAxMDAwID0gY29udmVydCBzZWNvbmRzIHRvIG1pbGxpc2Vjb25kcy5cclxuXHR9XHJcbn1cclxuXHJcblxyXG4iXSwibmFtZXMiOlsiRmlsZVN5c3RlbUFkYXB0ZXIiLCJNYXJrZG93blZpZXciLCJub3JtYWxpemVQYXRoIiwiY2xpcGJvYXJkIiwibW9tZW50IiwiZ2V0QWxsVGFncyIsIkVPTCIsIk1vZGFsIiwiU2V0dGluZyIsIlBsYXRmb3JtIiwiUGx1Z2luU2V0dGluZ1RhYiIsInNldEljb24iLCJQbHVnaW4iLCJmcyIsImV4ZWMiLCJwYXRoIiwiTm90aWNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXVEQTtBQUNPLFNBQVMsU0FBUyxDQUFDLE9BQU8sRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRTtBQUM3RCxJQUFJLFNBQVMsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLE9BQU8sS0FBSyxZQUFZLENBQUMsR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUMsVUFBVSxPQUFPLEVBQUUsRUFBRSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRTtBQUNoSCxJQUFJLE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLE9BQU8sQ0FBQyxFQUFFLFVBQVUsT0FBTyxFQUFFLE1BQU0sRUFBRTtBQUMvRCxRQUFRLFNBQVMsU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7QUFDbkcsUUFBUSxTQUFTLFFBQVEsQ0FBQyxLQUFLLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7QUFDdEcsUUFBUSxTQUFTLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxNQUFNLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDLEVBQUU7QUFDdEgs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
